<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GAN学习笔记</title>
    <url>/2024/03/10/2024-03-10-GAN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考资料</p>
<p>开山之作：<a href="https://arxiv.org/pdf/1406.2661.pdf">https://arxiv.org/pdf/1406.2661.pdf</a></p>
<p>GAN lab: <a href="https://poloclub.github.io/ganlab/">https://poloclub.github.io/ganlab/</a></p>
<p>教程：<a href="https://arxiv.org/pdf/1701.00160.pdf">https://arxiv.org/pdf/1701.00160.pdf</a></p>
<p>DEMO：<a href="https://zhuanlan.zhihu.com/p/24767059">https://zhuanlan.zhihu.com/p/24767059</a></p>
<p>笔记参考：<a href="https://zhuanlan.zhihu.com/p/84783062">https://zhuanlan.zhihu.com/p/84783062</a></p>
<p>DCGAN: <a href="https://ar5iv.labs.arxiv.org/html/1511.06434">https://ar5iv.labs.arxiv.org/html/1511.06434</a></p>
<p>Spectral GAN: <a href="https://arxiv.org/abs/1802.05957">https://arxiv.org/abs/1802.05957</a></p>
<p>Conditional GAN: <a href="https://blog.csdn.net/qq_24224067/article/details/104293409">https://blog.csdn.net/qq_24224067/article/details/104293409</a></p>
</blockquote>
<h2 id="为什么学习生成模型？"><a href="#为什么学习生成模型？" class="headerlink" title="为什么学习生成模型？"></a>为什么学习生成模型？</h2><p>首先了解什么是生成模型，以及为什么要学习生成模型。回顾机器学习的定义，机器学习的任务是要学习事物的内在规律（分布），并做出预测。按照监督性学习的模式，比方说有一个人脸，我想让机器识别这个人脸的特征，并且通过与label关联（比方说这是谁）从而能够进行人脸识别，下次再看到一张脸可以输出识别率。</p>
<p>生成模型也是对人脸的特征进行学习，但是我的任务现在不是人脸识别，而是生成人脸，这在现实环境下有很大的应用场景，比方说把糊掉的照片修复，比方说通过勾勒线条生成好看的图，比方说智能P图等等。但是除了这些应用，生成模型还有更多的应用场景。</p>
<ul>
<li>从生成模型中训练和抽样是对我们表示和操纵高维概率分布能力的极好测试。这对数学和工程领域帮助很大。</li>
<li>生成模型能够生成对未来场景的预测，是基于模型的强化学习的一个很重要的组成部分。</li>
<li>生成模型适用于半监督学习场景 - - 有很多缺失label值的学习场景，因为它能够生成对应输入数据的label。</li>
</ul>
<p><img src="/./img/GAN1.png" alt="image-20240313142124930"></p>
<h2 id="GAN原理"><a href="#GAN原理" class="headerlink" title="GAN原理"></a>GAN原理</h2><p>我们想要模型能够生成和采样图片特征相似的图片，为此我们需要训练一个好的生成器，那么什么样的生成器才能叫“好的”呢？我们假设某种类型的图片张量是服从高维分布的的，设为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="4.742ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 2096.1 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1049,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(1410,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></g></g></svg></mjx-container>。我们的任务就是训练一个生成器，它也服从某种分布，设为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.898ex" height="1.92ex" role="img" focusable="false" viewBox="0 -683 1280.8 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></g></svg></mjx-container>，那我们的任务就是训练模型使得<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.898ex" height="1.92ex" role="img" focusable="false" viewBox="0 -683 1280.8 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></g></svg></mjx-container>足够接近<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="4.742ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 2096.1 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1049,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(1410,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></g></g></svg></mjx-container>。</p>
<p><img src="https://pic1.zhimg.com/80/v2-bc64f778f95312aa0c37d2ddb62358ec_1440w.webp" alt="img"></p>
<p>这个过程可以用下面的数学公式表述：</p>
<p><img src="/./img/GAN8.jpeg" alt="IMG_8C43CA7B3C74-1"></p>
<p><strong>GAN</strong>(General Adversarial Network)被叫做生成对抗网络，它涉及两个网络：生成器Generator和判别器Descriminator。两个网络在相互对抗的博弈过程中不断学习，最终训练出可以生成接近真实分布的模型。</p>
<p><img src="https://pic2.zhimg.com/v2-6277da1cacd7a7fb7c0d326eb47c2135_r.jpg" alt="img"></p>
<p>一开始生成器只能生成很模糊的图像，但是判别器效果也很差，所以我们训练一轮判别器直到判别器能够分辨出生成的图像和原来的图像。然后我们训练一轮生成器，直到上一轮的判别器无法分辨出真假。之后再训练判别器，生成器，判别器…如此循环往复，直至判别器再也分辨不出真假，我们就说生成模型已经足够“好“了。</p>
<p>GAN给出了模型优化的目标，公式如下：</p>
<p><img src="/./img/GAN2.png" alt="image-20240313203419409"></p>
<p>其中，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.419ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 627.3 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g><g data-mml-node="mspace"></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(55.3,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></svg></mjx-container>表示真实图片，D(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.419ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 627.3 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g><g data-mml-node="mspace"></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(55.3,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></svg></mjx-container>)表示判断图片为真实的概率，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.177ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 520.3 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g><g data-mml-node="mspace"></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(55.3,0)"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></g></svg></mjx-container>表示在高斯分布中随机选取的一个数据，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.715ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2084.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1175,0)"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g><g data-mml-node="mspace" transform="translate(1175,0)"></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1230.3,0)"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g><g data-mml-node="mo" transform="translate(1695.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>表示生成的图片，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.349ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3690.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mo" transform="translate(828,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1217,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(2003,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2392,0)"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g><g data-mml-node="mspace" transform="translate(2392,0)"></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2447.3,0)"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g><g data-mml-node="mo" transform="translate(2912.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3301.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>表示判断生成的图片是真实的概率。</p>
<p>推导发现，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.147ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6253.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="msub" transform="translate(1407,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="TeXAtom" transform="translate(605,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g></g></g><g data-mml-node="mi" transform="translate(2647.5,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(3416.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3805.5,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mo" transform="translate(4633.5,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(5078.2,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(5864.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>和 JS-Shannon Divergence是类似的，说明如下图：</p>
<p><img src="/./img/GAN10.jpeg" alt="IMG_E47CEE391EB6-1"></p>
<p>模型训练的算法如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9b9cf73c1064a87a26ef3c0f9eac7b76_1440w.webp" alt="img"></p>
<p>注意首先循环k次训练判别器，用随机梯度上升的方法，最大化目标函数，更新判别器参数；然后随机梯度下降最小化损失函数，更新生成器参数，如此反复迭代到指定次数即可。</p>
<h2 id="WGAN原理"><a href="#WGAN原理" class="headerlink" title="WGAN原理"></a>WGAN原理</h2><p>用JS divergence作为分布之间衡量差异的标准是不合适的，理由如下：</p>
<ol>
<li><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.902ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 4376.9 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1049,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(1410,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g><g data-mml-node="mi" transform="translate(2096.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g><g data-mml-node="msub" transform="translate(3096.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></g></svg></mjx-container>大概率不重合，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.902ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 4376.9 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1049,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(1410,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g><g data-mml-node="mi" transform="translate(2096.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g><g data-mml-node="msub" transform="translate(3096.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></g></svg></mjx-container>都是在高纬度下的低维流形，重合概率非常地小</p>
</li>
<li><p>GAN是从真实分布里取样，生成器也是从高斯分布中选取噪声，更是降低了取到重合数据的概率</p>
<p><img src="/./img/WGAN.jpeg" alt="IMG_DBC584E2C575-1"></p>
</li>
</ol>
<p>JS divergence有一个很重要的性质：除非两个分布重合，不然不管间隔多远，计算出来的divergence都是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="3.982ex" height="2.034ex" role="img" focusable="false" viewBox="0 -694 1760 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1260,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>。只有重合的时候才会有0的divergence。这样的性质会导致我们无法从数值中看到训练过程中生成模型到底好不好，只能人为地输出图片人眼查看，人们就在想能不能换一种表达分布之间距离的理论，于是就有了<strong>Wasserstein GAN</strong>。</p>
<p>来看看一种新的距离：Wasserstein distance</p>
<p><img src="/./img/GAN3.png" alt="image-20240314014613347"></p>
<p>想象一个推土机，要把一堆土从P推到Q，平均要移动的距离d就是Wasserstein distance。当有多个推土计划时，我们就穷举所有的计划，找到其中最小的平均距离作为我们的Wasserstein distance。数学表达式如下：</p>
<p><img src="/./img/GAN4.png" alt="image-20240314014925018"></p>
<p>其中D必须属于1 - Lipschitz，换句话说D必须尽可能地平滑。那么如何更好地说明D足够平滑呢？围绕这个问题有许多论文提出了方法，比如Improved WGAN, Improved improved WGAN, Spectral GAN。</p>
<h2 id="Conditional-GAN"><a href="#Conditional-GAN" class="headerlink" title="Conditional GAN"></a>Conditional GAN</h2><p>目的：加上一些条件信息，使得我们能够指定生成的内容。训练目标变为：</p>
<p><img src="https://img-blog.csdnimg.cn/20200213163306443.png" alt="在这里插入图片描述"></p>
<h3 id="应用1-文本生成图片"><a href="#应用1-文本生成图片" class="headerlink" title="应用1 文本生成图片"></a>应用1 文本生成图片</h3><p><img src="/./img/GAN5.png" alt="image-20240314021440308"></p>
<p>核心是训练出一个好的判别器，能够不止判断生成的图片的真实性，还能够判别文字标签和生成的图像符不符合。为此我们需要有监督地学习&lt;标签，图像&gt;对的判别，这个学习过程不仅要事先有监督地学习，还要在生成的过程中将标签和生成的图像成对进行训练。</p>
<h3 id="应用2-图片生成图片"><a href="#应用2-图片生成图片" class="headerlink" title="应用2 图片生成图片"></a>应用2 图片生成图片</h3><p>又叫Image Translation，比如给定图片线稿生成填色后的图片。原理和文本生成图片类似。</p>
<p><img src="/./img/GAN6.png" alt="image-20240314022151770"></p>
<h3 id="应用3-音频生成图片"><a href="#应用3-音频生成图片" class="headerlink" title="应用3 音频生成图片"></a>应用3 音频生成图片</h3><p><img src="/./img/GAN7.png" alt="image-20240314022300128"></p>
<h2 id="Unsupervised-Conditional-GAN"><a href="#Unsupervised-Conditional-GAN" class="headerlink" title="Unsupervised Conditional GAN"></a>Unsupervised Conditional GAN</h2>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>生成模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Day7 哈希表 Part2</title>
    <url>/2024/01/24/2024-01-24-Day7-%E5%93%88%E5%B8%8C%E8%A1%A8-Part2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-快乐数"><a href="#1-快乐数" class="headerlink" title="1 快乐数"></a>1 快乐数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p><strong>示例：</strong></p>
<p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</p>
<h3 id="1-2-思路解析"><a href="#1-2-思路解析" class="headerlink" title="1.2 思路解析"></a>1.2 思路解析</h3><p>刚开始还以为这是个数学题，总是想着是不是会出现6和8的组合才是快乐数，仔细想又不是这样，因为如果数字的位数多的话完全可以不是6和8的组合凑成10，100，或者1000这样子。</p>
<p>后来看解析焕然大悟，真是太久没有写题了，一个浅显的道理都没有意识到：<mark>如果不是快乐数，那么通过求平方算出来的数字一定会出现重复的数字</mark>，由于是在数组中查找对应元素，所以用哈希表最快，所以数据结构选用<code>set</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">computeJoyNum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(n % <span class="number">10</span>,<span class="number">2</span>) + <span class="built_in">computeJoyNum</span>(n/<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = n;</span><br><span class="line">        <span class="keyword">while</span>(mySet.<span class="built_in">find</span>(m) == mySet.<span class="built_in">end</span>())&#123;</span><br><span class="line">            mySet.<span class="built_in">insert</span>(m);</span><br><span class="line">            m = <span class="built_in">computeJoyNum</span>(m);</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意，CPP中的求幂运算是<code>std::pow</code>函数，<code>^</code>是按位异或运算。</p>
<h2 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2 两数之和"></a>2 两数之和</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p>
<p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p>
<p>所以返回 [0, 1]</p>
<h3 id="2-2-思路解析"><a href="#2-2-思路解析" class="headerlink" title="2.2 思路解析"></a>2.2 思路解析</h3><p>这个题只涉及两个数，所以在总体策略上，只需要将数组元素插入到一个我们自己构建的容器中，只要这个容器的查找速度够快，就能实现优于O(n$^2$)的时间复杂度。</p>
<p>刚开始我想到的其实是用set，我想着set内的元素是有序的，也许可以使用distance函数输出下标，但是提交的时候发现不对，查找资料后发现set的底层使用红黑树实现的，内部元素是有序的，但是不支持随机访问，也就是说不能通过下标的方式对元素进行查找。</p>
<p>所以我就在想换什么容器，数组的话当然可以，但是数组的查找效率太低，就算采用边排序边查找的方式，总共算下来的时间复杂度也要O($n^2$)。</p>
<p>于是考虑用map，可是map的底层实现也是红黑树，对于这种关联容器来说，cpp中STL与之绑定的迭代器是双向迭代器，而不是随机访问迭代器，所以不支持下标的随机访问。但是好在我们可以用空间换时间，map是一种键-值关联的数据结构，我们只需要在map的值的地方存取下标就好了。</p>
<p><mark>注意这里键是nums中的元素，值是对应元素的下标。不能交换位置，因为在unordered_map中，查找键的时间复杂度是O($log_{}{n}$)，而查找值的时间复杂度是O($n$)。</mark></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">       unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; s;  <span class="comment">//临时存储判断过的数字</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span> (s.<span class="built_in">find</span>(target - nums[i])!= s.<span class="built_in">end</span>())&#123;</span><br><span class="line">               ans.<span class="built_in">push_back</span>(s.<span class="built_in">find</span>(target - nums[i])-&gt;second);</span><br><span class="line">               ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">               <span class="keyword">return</span> ans;</span><br><span class="line">           &#125;</span><br><span class="line">           s.<span class="built_in">insert</span>(&#123;nums[i],i&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>我们使用<code>unordered_map</code>是因为其底层实现是哈希表，查找和插入元素的时间复杂度是O(1)。如果用map的话时间复杂度是O($log_{}{n}$)，性能不如哈希表实现。</p>
<h3 id="2-3-总结归纳"><a href="#2-3-总结归纳" class="headerlink" title="2.3 总结归纳"></a>2.3 总结归纳</h3><h4 id="2-3-1-Map用法总结"><a href="#2-3-1-Map用法总结" class="headerlink" title="2.3.1 Map用法总结"></a>2.3.1 Map用法总结</h4><p><code>std::map</code> 是 C++ 标准库中的关联容器，提供了基于键值对的映射。以下是对 <code>std::map</code> 常用的一些操作：</p>
<ol>
<li><p><strong>插入元素：</strong></p>
<ul>
<li>使用 <code>insert</code> 函数插入键值对：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;);</span><br><span class="line">myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>访问元素：</strong></p>
<ul>
<li>使用键访问元素，注意如果键不存在，会插入一个默认值：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; myMap = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br><span class="line">std::string value = myMap[<span class="number">1</span>]; <span class="comment">// 访问键为 1 的值</span></span><br></pre></td></tr></table></figure></li>
<li>使用 <code>find</code> 函数查找元素，避免插入默认值：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::string value = it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>删除元素：</strong></p>
<ul>
<li>使用 <code>erase</code> 函数删除指定键的元素：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">1</span>); <span class="comment">// 删除键为 1 的元素</span></span><br></pre></td></tr></table></figure></li>
<li>使用迭代器删除指定位置的元素：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    myMap.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>遍历元素：</strong></p>
<ul>
<li><p>使用迭代器遍历整个 <code>std::map</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="type">int</span> key = it-&gt;first;</span><br><span class="line">    std::string value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 使用 key 和 value 进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用范围循环（C++11 及以上版本）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">    <span class="type">int</span> key = pair.first;</span><br><span class="line">    std::string value = pair.second;</span><br><span class="line">    <span class="comment">// 使用 key 和 value 进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>获取容器大小：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> size = myMap.<span class="built_in">size</span>(); <span class="comment">// 返回键值对的数量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>判断元素是否存在：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (myMap.<span class="built_in">find</span>(<span class="number">1</span>) != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 键为 1 的元素存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清空容器：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap.<span class="built_in">clear</span>(); <span class="comment">// 清空所有键值对</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-3-2-迭代器回顾"><a href="#2-3-2-迭代器回顾" class="headerlink" title="2.3.2 迭代器回顾"></a>2.3.2 迭代器回顾</h4><p>C++ 标准库中的迭代器分为五种主要类型，按功能和能力的不同逐步增强，分别是：</p>
<ol>
<li><strong>输入迭代器（Input Iterator）：</strong> 只能读取序列中的元素，但不能修改。支持逐个元素读取和后移，不支持随机访问。</li>
<li><strong>输出迭代器（Output Iterator）：</strong> 只能写入序列中的元素，但不能读取。支持逐个元素写入和后移，不支持随机访问。</li>
<li><strong>前向迭代器（Forward Iterator）：</strong> 具备输入和输出迭代器的所有功能，并且可以多次遍历同一范围。支持逐个元素读写、前移和后移，不支持随机访问。</li>
<li><strong>双向迭代器（Bidirectional Iterator）：</strong> 具备前向迭代器的所有功能，并且可以反向遍历。支持逐个元素读写、前移和后移，但不支持随机访问。</li>
<li><strong>随机访问迭代器（Random Access Iterator）：</strong> 具备双向迭代器的所有功能，并且支持随机访问。可以通过迭代器进行跳跃式的访问和修改。支持逐个元素读写、前移、后移、随机访问、加法和减法运算等。</li>
</ol>
<p>不同的 C++ 容器提供不同类型的迭代器。以下是一些常见容器及其迭代器类型：</p>
<ol>
<li><p><strong>数组：</strong></p>
<ul>
<li>迭代器类型：随机访问迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* begin = std::<span class="built_in">begin</span>(arr);</span><br><span class="line"><span class="type">int</span>* end = std::<span class="built_in">end</span>(arr);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>向量（<code>std::vector</code>）：</strong></p>
<ul>
<li>迭代器类型：随机访问迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = vec.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>列表（<code>std::list</code>）：</strong></p>
<ul>
<li>迭代器类型：双向迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = myList.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>双端队列（<code>std::deque</code>）：</strong></p>
<ul>
<li>迭代器类型：随机访问迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; myDeque = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = myDeque.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = myDeque.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>集合（<code>std::set</code>）：</strong></p>
<ul>
<li>迭代器类型：双向迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = mySet.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>映射（<code>std::map</code>）：</strong></p>
<ul>
<li>迭代器类型：双向迭代器（针对 <code>std::map</code> 和 <code>std::set</code> 中的键值对）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; myMap = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = myMap.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>无序集合（<code>std::unordered_set</code>）：</strong></p>
<ul>
<li>迭代器类型：前向迭代器（C++11 及以上版本）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; myUnorderedSet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = myUnorderedSet.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = myUnorderedSet.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>无序映射（<code>std::unordered_map</code>）：</strong></p>
<ul>
<li>迭代器类型：前向迭代器（C++11 及以上版本）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myUnorderedMap = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = myUnorderedMap.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = myUnorderedMap.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这只是一些基本的例子，具体的迭代器类型可能还受到 C++ 标准库实现的影响。在编写代码时，可以使用 <code>std::begin</code> 和 <code>std::end</code> 函数来获取容器的起始和结束迭代器。在 C++11 及以上版本，可以使用 <code>auto</code> 关键字简化迭代器的声明。</p>
<h2 id="3-四数之和"><a href="#3-四数之和" class="headerlink" title="3 四数之和"></a>3 四数之和</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p>
<p><strong>例如:</strong></p>
<p>输入:</p>
<ul>
<li>A &#x3D; [ 1, 2]</li>
<li>B &#x3D; [-2,-1]</li>
<li>C &#x3D; [-1, 2]</li>
<li>D &#x3D; [ 0, 2]</li>
</ul>
<p>输出:</p>
<p>2</p>
<p><strong>解释:</strong></p>
<p>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li>
</ol>
<h3 id="3-2-思路解析"><a href="#3-2-思路解析" class="headerlink" title="3.2 思路解析"></a>3.2 思路解析</h3><p>本题看着是一个组合数学的问题，但其实可以把两个数组能加和出的数字合在一个容器中，因为本题只需要我们输出元组个数，所以我们可以用map来存储加和出的数字及其出现次数。</p>
<p>最开始我的想法是A和B统计一次，C和D再统计一次，然后再进行哈希表的匹配搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; sums1;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; sums2;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sums1.<span class="built_in">find</span>(i + j)==sums1.<span class="built_in">end</span>())</span><br><span class="line">                sums1.<span class="built_in">insert</span>(&#123;i+j,<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sums1.<span class="built_in">find</span>(i+j)-&gt;second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:nums3)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j:nums4)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sums2.<span class="built_in">find</span>(i+j) == sums2.<span class="built_in">end</span>())</span><br><span class="line">                sums2.<span class="built_in">insert</span>(&#123;i+j,<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sums2.<span class="built_in">find</span>(i+j)-&gt;second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair:sums1)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sums2.<span class="built_in">find</span>(<span class="number">-1</span> * pair.first) != sums2.<span class="built_in">end</span>())</span><br><span class="line">            ans += (pair.second * sums2.<span class="built_in">find</span>(<span class="number">-1</span> * pair.first)-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是看了解析之后，发现其实还有更加高效的办法，其实只需要统计A和B的加和情况。然后在遍历C和D的过程中进行哈希搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; sums1&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> counts = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 首先计算nums1和nums2的加和可能情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j:nums2)</span><br><span class="line">            sums1[i + j]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:nums3)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j:nums4)</span><br><span class="line">            <span class="keyword">if</span> (sums1[-i-j])</span><br><span class="line">                counts += sums1[-i-j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法,哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy： 对Axis的理解</title>
    <url>/2024/04/10/2024-04-10-Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><strong>Axis 就是数组层级</strong></li>
<li><strong>设 axis=i，则 Numpy 沿着第 i 个下标变化的方向进行操作</strong></li>
<li><strong>Axis 的应用</strong></li>
</ul>
<h2 id="Axis-就是数组层级"><a href="#Axis-就是数组层级" class="headerlink" title="Axis 就是数组层级"></a><strong>Axis 就是数组层级</strong></h2><p>要想理解 axis，首先我们先要弄清楚 “Numpy 中数组的维数” 和 “线性代数中矩阵的维数” 这两个概念以及它们之间的关系。在数学或者物理的概念中，dimensions 被认为是在空间中表示一个点所需要的最少坐标个数，但是在 Numpy 中，dimensions 指代的是数组的维数。比如下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; a = np.array([[1,2,3],[2,3,4],[3,4,9]])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [2, 3, 4],</span><br><span class="line">       [3, 4, 9]])</span><br></pre></td></tr></table></figure>

<p>这个 array 的维数只有 2，即 axis 轴有两个，分别是 axis=0 和 axis=1。如下图所示，该二维数组的第 0 维 (axis=0) 有三个元素 (左图)，即 axis=0 轴的长度 length 为 3；第 1 维(axis=1) 也有三个元素(右图)，即 axis=1 轴的长度 length 为 3。正是因为 axis=0、axis=1 的长度都为 3，矩阵横着竖着都有 3 个数，所以该矩阵在线性代数是 3 维的(rank 秩为 3)。</p>
<p><img src="https://pic4.zhimg.com/v2-76b727aedf756d03c854f3b045345c23_r.jpg"></p>
<p>因此，axis 就是数组层级。</p>
<p>当 axis=0，该轴上的元素有 3 个 (数组的 size 为 3)</p>
<p><code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code></p>
<p>当 axis=1，该轴上的元素有 3 个 (数组的 size 为 3)</p>
<p><code>a[0][0]</code>、<code>a[0][1]</code>、<code>a[0][2]</code></p>
<p>（或者<code>a[1][0]</code>、<code>a[1][1]</code>、<code>a[1][2]</code>）</p>
<p>（或者<code>a[2][0]</code>、<code>a[2][1]</code>、<code>a[2][2]</code>）</p>
<p>再比如下面 shape 为 (3,2,4) 的 array：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b = np.array([[[1,2,3,4],[1,3,4,5]],[[2,4,7,5],[8,4,3,5]],[[2,5,7,3],[1,5,3,7]]])</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">array([[[1, 2, 3, 4],</span><br><span class="line">        [1, 3, 4, 5]],</span><br><span class="line"></span><br><span class="line">       [[2, 4, 7, 5],</span><br><span class="line">        [8, 4, 3, 5]],</span><br><span class="line"></span><br><span class="line">       [[2, 5, 7, 3],</span><br><span class="line">        [1, 5, 3, 7]]])</span><br><span class="line">&gt;&gt;&gt; b.shape</span><br><span class="line">(3, 2, 4)</span><br></pre></td></tr></table></figure>

<p>这个 shape（用 tuple 表示）可以理解为在每个轴（axis）上的 size，也即占有的长度（length)。为了更进一步理解，我们可以暂时把多个 axes 想象成多层 layers。axis=0 表示第一层 (下图黑色框框)，该层数组的 size 为 3，对应轴上的元素 length = 3；axis=1 表示第二层 (下图红色框框)，该层数组的 size 为 2，对应轴上的元素 length = 2；axis=2 表示第三层 (下图蓝色框框)，对应轴上的元素 length = 4。</p>
<p><img src="https://pic3.zhimg.com/v2-5c8aad40f74a3adee72f8f7fb5be89a6_b.jpg"></p>
<h2 id="设-axis-x3D-i，则-Numpy-沿着第-i-个下标变化的方向进行操作"><a href="#设-axis-x3D-i，则-Numpy-沿着第-i-个下标变化的方向进行操作" class="headerlink" title="设 axis=i，则 Numpy 沿着第 i 个下标变化的方向进行操作"></a><strong>设 axis=i，则 Numpy 沿着第 i 个下标变化的方向进行操作</strong></h2><ol>
<li>二维数组示例：</li>
</ol>
<p>比如<code>np.sum(a, axis=1)</code>，结合下面的数组， <code>a[0][0]</code>=1、<code>a[0][1]</code>=2、<code>a[0][2]</code>=3 ，下标会发生变化的方向是数组的第一维。</p>
<p><img src="https://pic3.zhimg.com/v2-7a0716230a6f3d4840a6098001b1d2a2_b.jpg"></p>
<p>我们往下标会变化的方向，把元素相加后即可得到最终结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [6],</span><br><span class="line">  [9],</span><br><span class="line">  [16]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>三维数组示例：</li>
</ol>
<p>再举个例子，比如下边这个<code>np.shape(a)=(3,2,4)</code>的 3 维数组，该数组第 0 维的长度为 3(黑色框框)，再深入一层，第 1 维的长度为 2(红色框框)，再深入一层，第 2 维的长度为 4(蓝色框框)。</p>
<p><img src="https://pic3.zhimg.com/v2-2036beabc1c7e7d5dc8437a475766052_r.jpg"></p>
<p>如果我们要计算<code>np.sum(a, axis=1)</code>，在第一个黑色框框中，</p>
<p><img src="https://pic3.zhimg.com/v2-f77a4317e1fe6f139718acb7c80a3e86_b.jpg"></p>
<p>下标的变化方向如下所示：</p>
<p><img src="https://pic2.zhimg.com/v2-4b303d4c375ed35f2e3a336287b0980d_b.jpg"></p>
<p>所以，我们要把上下两个红色框框相加起来</p>
<p><img src="https://pic1.zhimg.com/v2-6ab2e0351a2a84204be79acfe7c399d8_b.jpg"></p>
<p>按照同样的逻辑处理第二个和第三个黑色的框框，可以得出最终结果：</p>
<p><img src="https://pic4.zhimg.com/v2-be09442b6ad87f96932412c5b8ab6fe3_r.jpg"></p>
<p>所以，依然是我们前边总结的那一句话，设 axis=i，则 Numpy 沿着第 i 个下标变化的方向进行操作。</p>
<p><img src="https://pic2.zhimg.com/v2-4b303d4c375ed35f2e3a336287b0980d_b.jpg"></p>
<ol start="3">
<li>四维数组示例：</li>
</ol>
<p>比如下面这个巨复杂的 4 维数组，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data = np.random.randint(0, 5, [4,3,2,3])</span><br><span class="line">&gt;&gt;&gt; data</span><br><span class="line">array([[[[4, 1, 0],</span><br><span class="line">         [4, 3, 0]],</span><br><span class="line">        [[1, 2, 4],</span><br><span class="line">         [2, 2, 3]],</span><br><span class="line">        [[4, 3, 3],</span><br><span class="line">         [4, 2, 3]]],</span><br><span class="line"></span><br><span class="line">       [[[4, 0, 1],</span><br><span class="line">         [1, 1, 1]],</span><br><span class="line">        [[0, 1, 0],</span><br><span class="line">         [0, 4, 1]],</span><br><span class="line">        [[1, 3, 0],</span><br><span class="line">         [0, 3, 0]]],</span><br><span class="line"></span><br><span class="line">       [[[3, 3, 4],</span><br><span class="line">         [0, 1, 0]],</span><br><span class="line">        [[1, 2, 3],</span><br><span class="line">         [4, 0, 4]],</span><br><span class="line">        [[1, 4, 1],</span><br><span class="line">         [1, 3, 2]]],</span><br><span class="line"></span><br><span class="line">       [[[0, 1, 1],</span><br><span class="line">         [2, 4, 3]],</span><br><span class="line">        [[4, 1, 4],</span><br><span class="line">         [1, 4, 1]],</span><br><span class="line">        [[0, 1, 0],</span><br><span class="line">         [2, 4, 3]]]])</span><br></pre></td></tr></table></figure>

<p>当 axis=0 时，numpy 沿着第 0 维的方向进行求和，也就是第一个元素值 = a0000+a1000+a2000+a3000=11, 第二个元素 = a0001+a1001+a2001+a3001=5，同理可得最后的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data.sum(axis=0)</span><br><span class="line">array([[[11,  5,  6],</span><br><span class="line">        [ 7,  9,  4]],</span><br><span class="line"></span><br><span class="line">       [[ 6,  6, 11],</span><br><span class="line">        [ 7, 10,  9]],</span><br><span class="line"></span><br><span class="line">       [[ 6, 11,  4],</span><br><span class="line">        [ 7, 12,  8]]])</span><br></pre></td></tr></table></figure>

<p>当 axis=3 时，numpy 沿着第 3 维的方向进行求和，也就是第一个元素值 = a0000+a0001+a0002=5, 第二个元素 = a0010+a0011+a0012=7，同理可得最后的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data.sum(axis=3)</span><br><span class="line">array([[[ 5,  7],</span><br><span class="line">        [ 7,  7],</span><br><span class="line">        [10,  9]],</span><br><span class="line"></span><br><span class="line">       [[ 5,  3],</span><br><span class="line">        [ 1,  5],</span><br><span class="line">        [ 4,  3]],</span><br><span class="line"></span><br><span class="line">       [[10,  1],</span><br><span class="line">        [ 6,  8],</span><br><span class="line">        [ 6,  6]],</span><br><span class="line"></span><br><span class="line">       [[ 2,  9],</span><br><span class="line">        [ 9,  6],</span><br><span class="line">        [ 1,  9]]])</span><br></pre></td></tr></table></figure>

<h2 id="Axis-的应用"><a href="#Axis-的应用" class="headerlink" title="Axis 的应用"></a><strong>Axis 的应用</strong></h2><p>例如现在我们收集了四个同学对苹果、榴莲、西瓜这三种水果的喜爱程度进行打分的数据（总分为 10），每个同学都有三个特征：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; item = np.array([[1,4,8],[2,3,5],[2,5,1],[1,10,7]])</span><br><span class="line">&gt;&gt;&gt; item</span><br><span class="line">array([[1, 4, 8],</span><br><span class="line">       [2, 3, 5],</span><br><span class="line">       [2, 5, 1],</span><br><span class="line">       [1, 10, 7]])</span><br></pre></td></tr></table></figure>

<p>每一行包含了同一个人的三个特征，如果我们想看看哪个同学最喜欢吃水果，那就可以用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; item.sum(axis = 1)</span><br><span class="line">array([13, 10,  8, 18])</span><br></pre></td></tr></table></figure>

<p>可以大概看出来同学 4 最喜欢吃水果。</p>
<p>如果我们想看看哪种水果最受欢迎，那就可以用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; item.sum(axis = 0)</span><br><span class="line">array([ 6, 22, 21])</span><br></pre></td></tr></table></figure>

<p>可以看出基本是<strong>榴莲</strong>最受欢迎。</p>
<h2 id="低维度axis理解"><a href="#低维度axis理解" class="headerlink" title="低维度axis理解"></a>低维度axis理解</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>对于一维数组，只有一个轴：</p>
<ul>
<li><code>axis=0</code>：这是唯一的轴，代表数组的唯一维度。</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组（例如矩阵）有两个轴：</p>
<ul>
<li><code>axis=0</code>：代表行。对于操作而言，这意味着会==沿着列的方向==进行，即跨越不同的行。</li>
<li><code>axis=1</code>：代表列。操作将沿着行的方向进行，即跨越不同的列。</li>
</ul>
<h3 id="三维数组"><a href="#三维数组" class="headerlink" title="三维数组"></a>三维数组</h3><p>对于三维数组，有三个轴：</p>
<ul>
<li><code>axis=0</code>：可以想象为不同的==”页”==或”深度层”。</li>
<li><code>axis=1</code>：在给定的页中，沿着”行”的方向。</li>
<li><code>axis=2</code>：在给定的页中，沿着”列”的方向。</li>
</ul>
<p>以三维数组为例，我们可以将其视为一个数据块，这个数据块由多个二维矩阵（页）堆叠而成。每个”页”是一个二维数组，有其自己的行和列。在这种情况下：</p>
<ul>
<li><code>axis=0</code> 表示沿着堆叠的方向，或者说是”深度”方向。==操作将跨越不同的页==。</li>
<li><code>axis=1</code> 表示在每个单独的页中，沿着行的方向。这意味着操作将在每页的所有行上进行，但是在同一页内。</li>
<li><code>axis=2</code> 表示在每个单独的页中，沿着列的方向。操作将在每页的所有列上进行，但是在同一页内。</li>
</ul>
<p>假设我们有一个三维数组 <code>arr</code>，它由 2 个 3x4 的二维数组（页）组成，形状为 <code>(2, 3, 4)</code>。这意味着我们有 2 页，每页 3 行 4 列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个三维数组，形状为 (2, 3, 4)</span></span><br><span class="line">arr = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                 [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                 [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]],</span><br><span class="line">                </span><br><span class="line">                [[<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>],</span><br><span class="line">                 [<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">                 [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>]]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>使用 <code>axis=0</code> 对数组进行求和：<code>np.sum(arr, axis=0)</code> 会将两个 3x4 的矩阵对应位置的元素相加，结果是一个 3x4 的矩阵。</li>
<li>使用 <code>axis=1</code> 对数组进行求和：<code>np.sum(arr, axis=1)</code> 对每个二维数组（页）的所有行进行求和，结果是每页一个行向量，形状变为 <code>(2, 4)</code>。</li>
<li>使用 <code>axis=2</code> 对数组进行求和：<code>np.sum(arr, axis=2)</code> 对每个二维数组（页）的所有列进行求和，结果是每页一个列向量，形状变为 <code>(2, 3)</code>。</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>算法系列 -- 三/四数之和</title>
    <url>/2024/05/01/2024%E5%B9%B44%E6%9C%8830%E6%97%A5_Algorithm_ThreeSum/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>我想到了下面几个思路：</p>
<ol>
<li>首先固定一个数，其余情况就是两数之和，时间复杂度O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.912ex" role="img" focusable="false" viewBox="0 -833.9 1036.6 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>)</li>
<li>三指针，大小指针相向移动，中间用二分搜索找出对应的值，如果能实现那么时间复杂度是O(nlogn)</li>
<li>三指针，固定一个数，另外两个左右指针相向移动，时间复杂度O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.912ex" role="img" focusable="false" viewBox="0 -833.9 1036.6 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>)</li>
</ol>
<p>第一种方法的难点在于去重逻辑的实现，据参考来源所说这种方法非常麻烦。<br>我最开始考虑的是第二种方法，但是仔细想来这种nlogn的方法是不可能实现的，因为如果根据大小指针相加的情况来移动指针的话，被移动掉的那个数的很多组合还不能被排除掉！所以这种方法会忽略掉很多种情况。</p>
<p>所以考虑采用第三种方法，但是为什么第三种方法的原理能够成立呢？因为内层循环能够穷尽所有两数之和，对于已经排过序的数组来说，采用大小指针的方式不断收缩，能够准确地搜索出每一个对应的两数之和组合。我们只需要在外层循环下套一个while(left &lt; right)的条件循环即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="comment">// 第一个剪枝操作，如果第一个元素已经大于0，就不可能再有和为0的了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 第二个剪枝操作，如果此i对应元素等于上一个i对应元素，那么直接跳过。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])   <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">int</span>(nums.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right){</span><br><span class="line">                <span class="type">int</span> comp = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (comp &lt; <span class="number">0</span>){</span><br><span class="line">                    left++;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; <span class="number">0</span>){</span><br><span class="line">                    right--;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[i], nums[left], nums[right]});</span><br><span class="line">                    <span class="comment">// 第三个剪枝操作，去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])    left++;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right]==nums[right - <span class="number">1</span>])    right--;</span><br><span class="line">                    left++;right--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></table></figure>

<p>注意代码中三个剪枝操作。这里解释一下后两个。</p>
<p>第二个剪枝操作关注的是如何在i移动的过程中去重，判断的是i位置的值是不是和上一个一样，因为如果和紧挨着的上一个值一样，那么<strong>可以构造的组合肯定已经包含在上一个值所处理的组合中了</strong>。注意这里我们不能判断当前值是否等于下一个值，因为当前值若与下一个值一样，还可以构造出一个额外的组合 - - 当前值加上下一个值再加上一个数等于0，所以我们需要这样的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])   <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>对于第三个去重方式，我们关注的是如何在left和right移动的过程中不加入重复的组合。对于一个已经找到的组合，我们需要移动left指针直至它指向一个更大的值，移动right指针直至它指向一个更小的值，但是还需要在这个过程中注意<code>left &lt; right</code>的条件，如果不加上这个条件的话就会出现<strong>下标访问超界</strong>的报错。(例子：[0,0,0,0])</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])    left++;</span><br><span class="line"><span class="keyword">while</span> (right&gt;left &amp;&amp; nums[right]==nums[right<span class="number">-1</span>])  right--;</span><br></pre></td></tr></table></figure>

<p>经过这个操作，left和right其实还是指向的是与找到的组合相同的值，我们还需要将其相向移动一次，然后要么是不重复的情况，要么就left &gt; right从而退出循环，进而将i加1</p>
<p>经过这两个去重操作，就无须构造set来去重了，就可以保证每一次加入到ans中的都是之前没有出现过的组合。</p>
<h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p>
<h2 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h2><p>这个题只需要在三数之和问题外再套一层循环即可，但还有一些细节的逻辑需要注意。在三数之和中，当遍历指针指向0的时候就退出循环，但是在这个题中不能这样剪枝，因为我们是判断和为target，不是固定的0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) {</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(nums.<span class="built_in">size</span>() - <span class="number">3</span>); i++){</span><br><span class="line">            <span class="comment">// 去重1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 固定i，进行三数之和的查找</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; (nums.<span class="built_in">size</span>() - <span class="number">2</span>); j++){</span><br><span class="line">                <span class="comment">// 去重2</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; (i+<span class="number">1</span>) &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = <span class="built_in">int</span>(nums.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right){</span><br><span class="line">                    <span class="type">long</span> comp = nums[j] + nums[left];</span><br><span class="line">                    comp += nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (comp &lt; (target - nums[i])){</span><br><span class="line">                        left++;</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; (target - nums[i])){</span><br><span class="line">                        right--;</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[i],nums[j],nums[left],nums[right]});</span><br><span class="line">                        <span class="comment">// 去重3</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])    left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right]==nums[right<span class="number">-1</span>])  right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>

<p>注意代码中的三个去重操作，和三数之和中的思想是类似的。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul>
<li><p>三数之和：<a href="https://www.programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://www.programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p>
</li>
<li><p>四数之和：<a href="https://www.programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://www.programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转单词</title>
    <url>/2024/05/03/2024%E5%B9%B45%E6%9C%883%E6%97%A5_Algorithm_ReverseWords/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>这道题的第一个难点是翻转，之前只接触过将字符串从头到尾翻转，但是如何以单词为基本单位进行翻转呢？</p>
<p>很自然地想到可以用<strong>翻转再翻转</strong>的方式处理，即先把每一个单词翻转，对于 the sky is blue 来说， 翻转成为 eht yks si eulb，然后再整体进行翻转，就得到了 blue is sky the这种形式。其实这种在数组中分块移动的方法非常常用，是一种固定的套路，也被称为左/右旋。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> st = <span class="number">0</span>, ed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (st &lt; s.<span class="built_in">size</span>()){</span><br><span class="line">	<span class="comment">// 翻转每一个单词</span></span><br><span class="line">	<span class="keyword">while</span> (ed &lt; s.<span class="built_in">length</span>() &amp;&amp; s.<span class="built_in">at</span>(ed) != <span class="string">' '</span>)</span><br><span class="line">		ed++;</span><br><span class="line">	<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + st, s.<span class="built_in">begin</span>() + ed);</span><br><span class="line">	<span class="comment">// 略去空格</span></span><br><span class="line">	<span class="keyword">while</span> (ed &lt; s.<span class="built_in">length</span>() &amp;&amp; s[ed]==<span class="string">' '</span>)  ed++;</span><br><span class="line">	st = ed;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 整体翻转</span></span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>通过上面的操作，就可以得到一个初具雏形的答案了，但是还不够，有下面的问题存在。</p>
<ol>
<li>上面的代码只是把所有的字符串重新排布好了，首尾的空格并没有清理掉。</li>
<li>词与词之间的空格可能有多个的情况需要处理。</li>
</ol>
<p>针对上面的情况，我们需要删掉字符串中的首尾空格和句中重复空格，最后得到现在的字符串的子集，所以我们可以用<strong>移除元素</strong>的方法，以<strong>O(n)的时间复杂度，O(1)的空间复杂度</strong>完成这件事情。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">st = <span class="number">0</span>,ed = s.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 除去首尾空格</span></span><br><span class="line"><span class="keyword">while</span> (s[st]==<span class="string">' '</span>)  st++;</span><br><span class="line"><span class="keyword">while</span> (s[ed]==<span class="string">' '</span>)  ed--;</span><br><span class="line"><span class="type">int</span> t = st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;st&lt;=ed;st++){</span><br><span class="line">	<span class="comment">// 移除词间重复的空格,经典的在第一个位置不作判断，而是从第二个位置开始，但是这里其实没必要引入t，st &gt; 0就可以了</span></span><br><span class="line">	<span class="comment">// 因为当st == t时s[st] != ' '恒成立（除去字符串本来就是空，那根本不会进行这个判断）</span></span><br><span class="line">	<span class="keyword">if</span> (st &gt; t &amp;&amp; s[st]==<span class="string">' '</span>&amp;&amp;s[st<span class="number">-1</span>]==<span class="string">' '</span>)   <span class="keyword">continue</span>;</span><br><span class="line">	s[j++]=s[st];</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 重新调整字符串大小</span></span><br><span class="line">s.<span class="built_in">resize</span>(j);</span><br></pre></td></tr></table></figure>

<p>我们重新定义一个覆盖指针j，根据满足要求的情况<strong>覆盖式地更新</strong>原字符串即可，这个过程中不会影响st空格的判断，因为<strong>j始终比st慢</strong>。<br>最后j就是新字符串的长度，我们用resize方法更新字符串长度即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个题主要考察双指针思想的理解，翻转操作利用的是相向指针，而移除空格，原地覆盖利用的是快慢指针。还有<code>reverse(iter, iter)</code>，<code>str.resize(size)</code>库函数的使用。除此之外还有两批次翻转（左旋/右旋）的思想。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN学习笔记</title>
    <url>/2024/03/09/CNN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考资料</p>
<p>可视化网站：<a href="https://poloclub.github.io/cnn-explainer/#article-input">https://poloclub.github.io/cnn-explainer/#article-input</a></p>
<p>卷积&amp;全连接&amp;卷积模式：<a href="https://zhuanlan.zhihu.com/p/76606892">https://zhuanlan.zhihu.com/p/76606892</a></p>
<p>骰子例子：<a href="https://www.zhihu.com/question/22298352">https://www.zhihu.com/question/22298352</a></p>
</blockquote>
<p>自从我转专业到软件以来，卷积神经网络这个词就一直萦绕在我耳边，CNN的大名也是无数次地听到。但即使如此，对于什么是卷积，对于卷积神经网络训练的过程，我从来没有真正掌握，今天在选修课上又一次接触到了这一概念，想到之后保研面试肯定是要问这些的，不如现在就趁着时间还早打好基础，把机器学习的系统思维真正地构建起来，为之后的保研和陶瓷做准备。</p>
<p><img src="/./img/CNN1.png" alt="image-20240309003157678"></p>
<h2 id="1-卷积"><a href="#1-卷积" class="headerlink" title="1 卷积"></a>1 卷积</h2><p>“卷积”一词来源于信号处理领域，人们想要知道一个输入信号在经过一个可以用单位冲击响应函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.656ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1616 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mo" transform="translate(477,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(866,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(1227,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>描述的线性系统后的输出是什么，由此引出了卷积运算。</p>
<p>假设有输入信号<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.821ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1689 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(1300,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>和系统响应<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.656ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1616 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mo" transform="translate(477,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(866,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(1227,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>如下：</p>
<p><img src="https://picx.zhimg.com/v2-59c8bcf17c24119810ad3071b960f1ba_r.jpg?source=1def8aca" alt="img"></p>
<p>首先要知道，某一时刻的信号输出值是当前和之前所有输入信号的累积效果，我现在想知道<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.157ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 3163.6 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(638.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1694.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(2694.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container>时信号的输出值，那么就要考虑<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.24ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4084.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(638.8,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mo" transform="translate(1583.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1861.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(2361.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(2806.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(3806.2,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>的情况，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.267ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2328 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1939,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>是刚输入的所以输出分量为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4083 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1939,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(2328,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mo" transform="translate(2805,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(3194,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(3694,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。f(9)已经输入了1s，所以输出分量为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.106ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3583 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g><g data-mml-node="mo" transform="translate(1439,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(1828,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mo" transform="translate(2305,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(2694,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3194,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。由此一直累加到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4083 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(1439,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(1828,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mo" transform="translate(2305,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(2694,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(3694,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<p><img src="https://picx.zhimg.com/80/v2-847a8d7c444508862868fa27f2b4c129_1440w.webp?source=1def8aca" alt="img"></p>
<p>由此可推导出连续函数的卷积公式：</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a9342b735529a84cbd078ea905f94c79df9a4103" alt="{\displaystyle (f*g)(t)\triangleq \int _{-\infty }^{\infty }f(\tau )g(t-\tau )\,\mathrm {d} \tau }"></p>
<p>离散型随机变量也可以进行卷积，只要把上面的积分换成求和即可，但是在那之前，我们先从概率论的角度推一遍卷积公式。</p>
<p>条件非常简单，求两个独立随机变量X、Y的和Z = X + Y的概率密度函数。</p>
<p><img src="/./img/CNN7.jpeg" alt="IMG_1F0AA84E73E6-1"></p>
<p>我们再来看看离散型随机变量的例子，我们以掷骰子为例，由前面的证明我们知道，我们需要构造的是两次掷的骰子点数之和。</p>
<p>假设我们要求<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="26.288ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11619.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(751,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1140,0)"><path data-c="1D44D" d="M58 8Q58 23 64 35Q64 36 329 334T596 635L586 637Q575 637 512 637H500H476Q442 637 420 635T365 624T311 598T266 548T228 469Q227 466 226 463T224 458T223 453T222 450L221 448Q218 443 202 443Q185 443 182 453L214 561Q228 606 241 651Q249 679 253 681Q256 683 487 683H718Q723 678 723 675Q723 673 717 649Q189 54 188 52L185 49H274Q369 50 377 51Q452 60 500 100T579 247Q587 272 590 277T603 282H607Q628 282 628 271Q547 5 541 2Q538 0 300 0H124Q58 0 58 8Z"></path></g><g data-mml-node="mo" transform="translate(2140.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3196.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(3696.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4363.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(5419.1,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(6170.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6559.1,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(7633.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(8633.6,0)"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"></path></g><g data-mml-node="mo" transform="translate(9674.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(10730.1,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(11230.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，由上面的公式我们知道应该是</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.819ex;" xmlns="http://www.w3.org/2000/svg" width="23.173ex" height="6.73ex" role="img" focusable="false" viewBox="0 -1728.7 10242.7 2974.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1439,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2105.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munderover" transform="translate(3161.6,0)"><g data-mml-node="mo"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="TeXAtom" transform="translate(148.2,-1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(545.2,1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4772.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(751,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1140,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1485,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(1874,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(2625,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(3014,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(3736.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(4736.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5081.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container><br>。对应在图像上就是先把第二个骰子“卷”过来再对应位置相加相乘。</p>
<p><img src="https://picx.zhimg.com/v2-860cdc53a489be168e9a12845c7eadc4_r.jpg?source=1def8aca" alt="img"></p>
<p>CNN中所用的是多维互相关，也就是没有翻转的卷积。我们先来看多维卷积，具体来说是二维，公式如下：</p>
<p><img src="/./img/CNN2.png" alt="image-20240309142927669"></p>
<p>该操作需要先将卷积核翻转，然后再与输入点相乘。但是CNN中省略了翻转这一过程，因为翻转本身没有什么意义，还会改变特征的方向特征，所以CNN中用的是互相关(Cross-Correlation):</p>
<p><img src="/./img/CNN3.png" alt="image-20240309143618906"></p>
<p>另外，卷积操作其实就是对输入向量乘以一个稀疏的全连接矩阵。</p>
<blockquote>
<p>卷积和全连接<strong>实质上都是一组线性转换</strong>，但是卷积相比全连接而言，其参数矩阵更加稀疏，kernel matrix 中很多为零（sparse connectivity），同时非零部分的参数实际上是共享的（parameter sharing）。这两个特点让卷积<strong>可以大大减少参数的数量，同时同一套参数（卷积核）在多个地方复用更有利于捕捉局部的特征</strong>。</p>
</blockquote>
<p>卷积有三种模式，分别是FULL,VALID和SAME模式。下面的图像可以直观表述它们的区别：</p>
<ul>
<li>FULL: - - 从有相交的地方开始卷积，该方法输出的尺寸最大</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-23ba5f401533b72b0214bd51a091000c_1440w.webp" alt="img"></p>
<ul>
<li>VALID - - 从重叠的地方开始卷积，参考网站用的就是这种方法</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-fc57effd13fdf64eeb375f57e65e309d_1440w.webp" alt="img"></p>
<ul>
<li>SAME – 输出大小 = 输入大小，可能需要不对称Padding</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-a18f53d4f4d60a0eb6d1940d06bd5af5_1440w.webp" alt="img"></p>
<h2 id="2-CNN基本概念"><a href="#2-CNN基本概念" class="headerlink" title="2 CNN基本概念"></a>2 CNN基本概念</h2><p>CNN首先是一个神经网络，是一种用来在数据中识别模式的算法。神经网络是由一系列组织成层的有着Weights和Bias参数的神经元构成的。</p>
<ul>
<li>tensor张量，表示多维数组，0维张量就是数字，1维张量就是向量，2维张量就是矩阵，n维张量就是n维矩阵。</li>
<li>Neuron神经元是一个接受多个输入，提供一个输出的计算单元</li>
<li>Layer层是一系列执行相同类型操作的神经元的集合，它们有相同的超参数(P,KS,S)</li>
<li>Weights&amp;Bias权重与偏置是每一个神经元在训练的时候优化的参数。</li>
</ul>
<h2 id="3-CNN层"><a href="#3-CNN层" class="headerlink" title="3 CNN层"></a>3 CNN层</h2><h3 id="3-1-Input-Layer输入层"><a href="#3-1-Input-Layer输入层" class="headerlink" title="3.1 Input Layer输入层"></a>3.1 Input Layer输入层</h3><p>由于CNN一般被用来处理图片分类问题，所以一般输入图片有RGB三个通道。</p>
<h3 id="3-2-Convolutional-Layer卷积层"><a href="#3-2-Convolutional-Layer卷积层" class="headerlink" title="3.2 Convolutional Layer卷积层"></a>3.2 Convolutional Layer卷积层</h3><p>这是CNN的核心层，重要的是分清楚两层之间的联系。注意到下图中的卷积层是全连接的，也就是说每一个卷积层神经元都连接着上一个层的所有神经元，用含有相同超参数，但是具体weight不同的卷积核对三个通道分别进行卷积后再将对应位置的值相加，最后加上偏置向量Bias就完成了一个神经元的计算。</p>
<p>需要注意的是，如果按照这种全连接的方式，在input和conv层之间就需要3 * 10 = 30个有着不同weights的卷积核。</p>
<p><img src="https://poloclub.github.io/cnn-explainer/assets/figures/convlayer_overview_demo.gif" alt="clicking on topmost first conv. layer activation map"></p>
<h3 id="3-3-Pooling-Layer池化层"><a href="#3-3-Pooling-Layer池化层" class="headerlink" title="3.3 Pooling Layer池化层"></a>3.3 Pooling Layer池化层</h3><p>池化层的目的是减小网络规模，降低计算量和计算成本。</p>
<p>其中用的最多的是最大池化层，这种方法用一个预先取定大小和步长的池化核遍历图片，将每种遍历情况下的最大值构建新的张量值，直到遍历完成。</p>
<p>池化的优点是可以简化网络计算，避免过拟合风险。</p>
<h3 id="3-4-Flatten-Layer展平层"><a href="#3-4-Flatten-Layer展平层" class="headerlink" title="3.4 Flatten Layer展平层"></a>3.4 Flatten Layer展平层</h3><p>在模型输出之前，我们需要将张量展平，以便使用Softmax function进行激活并输出预测结果。</p>
<h2 id="4-超参数解析"><a href="#4-超参数解析" class="headerlink" title="4 超参数解析"></a>4 超参数解析</h2><p>假设我们用VALID模式进行卷积，有对应关系F(input_size, padding, kernel_size, stride)</p>
<p><img src="/./img/CNN8.png" alt="image-20240309171000203"></p>
<p><img src="/./img/CNN4.png" alt="image-20240309145808631"></p>
<p><img src="/./img/CNN5.png" alt="image-20240309145840720"></p>
<h2 id="5-激活函数"><a href="#5-激活函数" class="headerlink" title="5 激活函数"></a>5 激活函数</h2><h3 id="5-1-RELU"><a href="#5-1-RELU" class="headerlink" title="5.1 RELU"></a>5.1 RELU</h3><p>RELU函数是典型的非线性激活函数，对于神经网络来说非常重要，神经网络之所以能够实现这么高的精度，很大一部分原因就是能够表达非线性关系，而RELU函数就是很好的表达。</p>
<p><img src="https://poloclub.github.io/cnn-explainer/assets/figures/relu_graph.png" alt="img"></p>
<h3 id="5-2-Softmax"><a href="#5-2-Softmax" class="headerlink" title="5.2 Softmax"></a>5.2 Softmax</h3><p><img src="/./img/CNN6.png" alt="image-20240309150210305"></p>
<p>Softmax函数非常适合用来作为输出层，因为其所有分量之和加起来是1，这就与概率天然挂钩了，而且由于其指数的特性，能够放大不同值之间的差异，从而更好地实现分类。</p>
<p>对于不同激活函数的介绍和差异，之前学吴恩达老师的课程的时候我写了一篇笔记，请参看：<a href="https://tj-jiaoao.github.io/2023/04/26/Activate_function/">https://tj-jiaoao.github.io/2023/04/26/Activate_function/</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Day6 哈希表Part1</title>
    <url>/2024/01/16/Day6%20%E5%93%88%E5%B8%8C%E8%A1%A8Part1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="哈希表基础"><a href="#哈希表基础" class="headerlink" title="哈希表基础"></a>哈希表基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>哈希表又称为散列表，是根据<mark>关键码的值</mark>而直接进行访问的数据结构。</li>
<li>哈希表解决的问题是：快速判断一个元素是否在一个集合中，</li>
<li><mark>HashFunction &#x3D; HashCode(name) % tableSize</mark>。也就是说，把各种数据格式（name）转化为索引，就可以实现快速访问了。</li>
<li>当不同的数据被映射到同一个哈希表上时，出现<code>哈希碰撞</code>，解决哈希碰撞的基本方法有：</li>
</ol>
<ul>
<li>拉链法：把发生冲突的元素存储到链表中。</li>
<li>线性探测法：向下找一个空位存放对应信息。</li>
</ul>
<h3 id="常见哈希结构"><a href="#常见哈希结构" class="headerlink" title="常见哈希结构"></a>常见哈希结构</h3><table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td><strong>std::unordered_set</strong></td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td><strong>std::unordered_map</strong></td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ol>
<li><mark>是否有序</mark>：红黑树是一种平衡二叉树，树的节点是有序的，而哈希表的实现是无序的。</li>
<li><mark>数值是否可以重复</mark>：只有multiset和multimap可以重复。</li>
<li><mark>能否更改数值</mark>：三种实现都不能更改数值。</li>
</ol>
<h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p>
<p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)   map[c] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)   map[c] --;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)   <span class="keyword">if</span>(map[c])  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)   <span class="keyword">if</span>(map[c])  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>核心就在于构造<code>char</code>到<code>int</code>的哈希映射。</p>
<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p>给定两个数组，计算它们的交集。</p>
<p>此题用set不难实现，主要是学习一下STL的set容器以及方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>()：创建一个空的set。</span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set&amp; other)：拷贝构造函数，创建一个与other一样的新set。</span><br><span class="line"><span class="built_in">set</span>(set&amp;&amp; other)：移动构造函数，将other的内容移动到新创建的set中。</span><br><span class="line">赋值操作</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> set&amp; other)：拷贝赋值运算符，用另一个set的拷贝替换当前内容。</span><br><span class="line"><span class="keyword">operator</span>=(set&amp;&amp; other)：移动赋值运算符，用另一个set的内容替换当前内容。</span><br><span class="line">迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">begin</span>() / <span class="built_in">cbegin</span>()：返回指向第一个元素的迭代器。</span><br><span class="line"><span class="built_in">end</span>() / <span class="built_in">cend</span>()：返回指向集合末尾的迭代器。</span><br><span class="line">容量</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()：检查set是否为空。</span><br><span class="line"><span class="built_in">size</span>()：返回set中元素的个数。</span><br><span class="line">修改操作</span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>()：移除所有元素，清空set。</span><br><span class="line"><span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; value)：插入元素。</span><br><span class="line"><span class="built_in">insert</span>(value_type&amp;&amp; value)：移动插入元素。</span><br><span class="line"><span class="built_in">erase</span>(iterator pos)：移除位于指定位置的元素。</span><br><span class="line"><span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; key)：移除指定键的元素。</span><br><span class="line"><span class="built_in">swap</span>(set&amp; other)：与另一个set交换内容。</span><br><span class="line">查找操作</span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>(<span class="type">const</span> key_type&amp; key)：返回某个值在set中出现的次数（由于set中元素唯一，结果为<span class="number">0</span>或<span class="number">1</span>）。</span><br><span class="line"><span class="built_in">find</span>(<span class="type">const</span> key_type&amp; key)：查找键为指定值的元素，如果找到，则返回一个指向该元素的迭代器，否则返回<span class="built_in">end</span>()。</span><br><span class="line"><span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp; key)：返回一个范围，包含所有与指定键相等的元素。</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums1)</span><br><span class="line">            s1.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums2)</span><br><span class="line">            s2.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:s1)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.<span class="built_in">find</span>(i)!= s2.<span class="built_in">end</span>())</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>核心在于运用set的<mark>自动去重功能</mark>。</p>
<p>但是这个题是可以展开思考的，如果交集是可重复集合，那么我们就可以构造<code>unordered_map</code>来记录数组中每个元素出现的次数，首先记录一个数组中元素出现的次数，然后遍历另一个数组中的元素，将非零的计数器的值减1并放入结果vector中即可。</p>
]]></content>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Macbook pro （M1 pro 2021款）语音识别环境搭建</title>
    <url>/2023/04/26/Macbook%20pro%20%EF%BC%88M1%20pro%202021%E6%AC%BE%EF%BC%89%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md%20622142e968f04dd9bd9a74015534c219/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>Anaconda</li>
<li>pycharm</li>
<li>Mac os Ventura 13.2.1</li>
</ul>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ol>
<li>安装Anaconda，然后在命令行里输入 <code>conda —version</code>(双横线） ，如果显示找不到conda的话，那就需要将conda加入到环境变量中。参考方法如下：（本教程使用了全局设置&#x2F;etc&#x2F;paths）</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/53209959">MAC 设置环境变量path的几种方法</a></p>
<ol>
<li>然后使用<code>conda create -n &lt;name&gt; python=3.7</code>创建虚拟环境，注意这里的python环境是3.7版本，如果用别的版本很可能会出问题！</li>
<li><code>conda activate &lt;name&gt;</code>激活虚拟环境</li>
<li>然后就可以使用<code>conda install &lt;package_name&gt;</code>来安装库了，注意安装的库在Users&#x2F;jiaoao&#x2F;anaconda3&#x2F;pkgs 文件夹中，也可以用<code>conda list</code>来显示已安装的库</li>
<li>🔥如果安装的过程中提示：****PackagesNotFoundError: The following packages are not available from current channels。 那么可以用<code>conda config - -append channels conda-forge</code>**它告诉conda在搜索软件包时也要在conda-forge channel上查看。如果还是不行，那么直接去anaconda官网上搜索对应版本即可</li>
<li>然后在pycharm环境中设计解释器为刚才创建的conda虚拟环境，之后就可以直接在pycharm上安装库了</li>
</ol>
]]></content>
      <tags>
        <tag>语音识别，Mac环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac m1 tensor-flow 和 sklearn环境配置</title>
    <url>/2023/04/26/Tensor_Flow&amp;Sklearn%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tensor-Flow-amp-Sklearn-环境配置"><a href="#Tensor-Flow-amp-Sklearn-环境配置" class="headerlink" title="Tensor Flow&amp;Sklearn 环境配置"></a>Tensor Flow&amp;Sklearn 环境配置</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Mac OS Ventura 13.2.1</li>
<li>Macbook pro M1 pro 2021</li>
<li>Python 3.9</li>
<li>conda 23.1.0</li>
</ul>
<h2 id="Tensor-Flow"><a href="#Tensor-Flow" class="headerlink" title="Tensor Flow"></a>Tensor Flow</h2><h3 id="检查自己的conda环境"><a href="#检查自己的conda环境" class="headerlink" title="检查自己的conda环境"></a><strong>检查自己的conda环境</strong></h3><p>虽然conda官方已提供minicoda的mac m1适配，但也不能用，一定需要miniforge3,如以前环境较乱，最好是删除自己装过的miniforge3环境重装。</p>
<p>安装miniforge3步骤</p>
<ol>
<li>删除已有环境</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">  rm -rf ~/miniforge3</span><br><span class="line">  rm -rf .conda</span><br><span class="line">  rm -rf .condarc</span><br><span class="line">  完成后，进入 .zshrc ，gg 将末端配置 miniforge3 的 PATH 配置删除。 ``</span><br></pre></td></tr></table></figure>

<ol>
<li>下载 <a href="https://link.zhihu.com/?target=https://github.com/conda-forge/miniforge/%23download">Miniforge3_MacOS_ARM64</a> <em>选择 Miniforge3-MacOSX-arm64</em></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x ~/Downloads/Miniforge3-MacOSX-arm64.sh</span><br><span class="line">   sh ~/Downloads/Miniforge3-MacOSX-arm64.sh</span><br><span class="line">   source ~/miniforge3/bin/activate</span><br><span class="line"></span><br><span class="line">   按提示装, 并确保.zshrc文件配置了miniforge3的</span><br><span class="line">   conda --version</span><br><span class="line">   安装路径一定要在/User/xiaomao/miniforge3, 不然可能有权限问题</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个conda环境</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3.8和3.9都可以，pytorch需要3.9</span><br><span class="line">   conda create -n tf26 python==3.9</span><br><span class="line">   conda create -n tf26 python==3.8</span><br></pre></td></tr></table></figure>

<p>完成以上的准备后，才正式开始安装tensorflow,可安装tensorflow2.5&#x2F;2.6,并且<strong>不需要再去github下载安装包</strong></p>
<h3 id="安装Tensorflow"><a href="#安装Tensorflow" class="headerlink" title="安装Tensorflow"></a><strong>安装Tensorflow</strong></h3><h3 id="1-切换到自己的conda环境"><a href="#1-切换到自己的conda环境" class="headerlink" title="1. 切换到自己的conda环境"></a><strong>1. 切换到自己的conda环境</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate tf26</span><br></pre></td></tr></table></figure>

<h3 id="2-依赖包tensorflow-deps的安装步骤"><a href="#2-依赖包tensorflow-deps的安装步骤" class="headerlink" title="2. 依赖包tensorflow-deps的安装步骤"></a><strong>2. 依赖包tensorflow-deps的安装步骤</strong></h3><p>详细步骤参考: <a href="https://link.zhihu.com/?target=https://developer.apple.com/metal/tensorflow-plugin/">apple开发者官网</a></p>
<p>未安装过的安装tensorflow依赖包，安装过的需要卸载旧版, 慢,需要科学上网</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. conda install -c apple tensorflow-deps    </span><br><span class="line"># 指定定版本安装   </span><br><span class="line">2. conda install -c apple tensorflow-deps==2.6.0</span><br></pre></td></tr></table></figure>

<h3 id="3-安装tensorflow"><a href="#3-安装tensorflow" class="headerlink" title="3. 安装tensorflow"></a><strong>3. 安装tensorflow</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install tensorflow-macos    </span><br><span class="line">*# 会有个报错, 自己安装下 pip install torch     然后再重新执行一遍* </span><br><span class="line">python -m pip install tensorflow-macos</span><br></pre></td></tr></table></figure>

<h3 id="4-安装tensorflow-metal"><a href="#4-安装tensorflow-metal" class="headerlink" title="4. 安装tensorflow-metal"></a><strong>4. 安装tensorflow-metal</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install tensorflow-metal</span><br></pre></td></tr></table></figure>

<h2 id="Sklearn"><a href="#Sklearn" class="headerlink" title="Sklearn"></a>Sklearn</h2><p>若想用conda安装sklearn，不能输入sklearn，而是<code>conda install scikit-learn</code></p>
]]></content>
  </entry>
  <entry>
    <title>KMP算法 - - 字符串搜索</title>
    <url>/2024/05/06/2024%E5%B9%B45%E6%9C%883%E6%97%A5_Algorithm_KMP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p>
<p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p>
<p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong></p>
<p>我们现在的问题是 <strong>在文本串中找到与模式串匹配的子串</strong>。待匹配的串称为文本串，做匹配的串称为模式串。</p>
<p>设文本串长m,模式串长n，显然暴力匹配时间复杂度为O(mn)。</p>
<p>问题在于每次匹配失败我都从文本串的<strong>下一个字母</strong>和模式串的<strong>第一个字母</strong>开始重新匹配，如果我能利用一些已经匹配的信息，这样就可以省去很多无用的操作。</p>
<p>进一步了解这个算法之前我们要先了解一下前缀和后缀。</p>
<ul>
<li><strong>前缀</strong>：包含字符串首位，不包含尾位的子串。</li>
<li><strong>后缀</strong>：包含字符串尾位，不包含首位的子串。</li>
</ul>
<p>KMP算法的核心就是找到匹配失败的前一个用来匹配的模式串子串的<strong>最长公共前后缀</strong>长度。</p>
<p>注意上面这段话不仅仅是在进行模式匹配的时候体现，<strong>在求前缀表的时候也有体现</strong>！</p>
<h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><h3 id="求前缀表"><a href="#求前缀表" class="headerlink" title="求前缀表"></a>求前缀表</h3><p>刚看完原理视频的时候觉得原理并不难理解，确实如此，如果考试让我写前缀表的话我可以很快地写出来，但是怎么在代码中高效实现求所有子串的前缀表呢？把所有前缀和后缀都写出来比较吗？笨方法，双指针法可以提高算法的效率。</p>
<p>设计双指针的原则是 一个遍历指针，另一个指向最长相等前缀。通过后面这个指针就可以知道当前子串的最长相等前后缀长度了。</p>
<p>首先初始化双指针和next数组。遍历指针i以及前缀指针j，next数组的长度和模式串长度相等。前缀指针j的值就是位置0 - i（包含i）的子串的最长公共前后缀长度。最开始只有一个字符，故初始化为0，next[0] = 0。所以我们从i = 1开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">next[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i++){</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>我们需要处理两类情况。</p>
<ol>
<li>i与j位置字符不匹配。</li>
<li>i与j位置字符匹配。</li>
</ol>
<p>直观的思想是：如果匹配，那么意味着找到相等的前后缀字符了，长度加一，j + 1.<br>如果不匹配，我就需要<strong>减小j直到字符匹配或者j减小到0都不匹配，next表项直接填0。</strong></p>
<p>直接一个个减j嘛？笨方法，和暴力解法没有区别，只是把暴力挪到了求前缀表的操作上。那应该怎么办呢？</p>
<p>答案就是： <strong>利用已经求出来的前缀表！</strong></p>
<p>这里我需要借用大佬博主的博客可视化地呈现情况。</p>
<p>匹配的情况是这样的。<br><img src="/img/KMP1.png" alt="img/KMP1.png"><br><img src="/img/KMP2.png" alt="img/KMP2.png"></p>
<p>如果遇到不匹配的情况如下：<br><img src="/img/KMP3.png" alt="img/KMP3.png"><br>显然深绿色的部分不能用了。<strong>我得在左边深绿色的部分中找到一个前缀，和以A作为结尾的后缀进行匹配</strong>。对应于下图（注意下图是以B作为结尾的后缀)就是<strong>大括号里的内容</strong>对应进行匹配。<br><img src="/img/KMP4.png" alt="img/KMP4.png"></p>
<p>换句话说，我需要在深绿色的部分中找到两个子区间，其中左边的子区间从模式子串最左边开始延伸，右边的子区间从模式子串B之前开始延伸。我需要找到最大长度的这两个子区间，来考察左区间加上？字符，右区间加上B是否匹配（其实也就是判断？是否等于B）这样就能够最大程度地利用已经进行过匹配的字符串。</p>
<p>通过上面的分析，其实已经可以知道：<strong>蓝色区间就是深绿色部分的最长公共前后缀！</strong> j要回退到的地方就是图中？的地方！对应于代码，就是A的上一个字符的next数组值！就是next[j-1]! 要进行的操作就是 j = next[j-1]!</p>
<p>神奇的操作，恕我见识有限，不知道这种像最优子结构但好像也不是的操作叫什么名字。和KMP的算法思想对应，我觉得可以认为：在拿深绿色部分 + A的子串作为模式串（因为我们有A之前的next表），深绿色部分 + B的子串作为文本串。当A和B不匹配时，就退回到？的地方。这就是KMP思想的体现！</p>
<p>个人觉得最难的地方已经讲完了，剩下的就只需要考虑一些逻辑条件和边界条件即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNextTable</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.length())</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i++){</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]){</span><br><span class="line">                j = next[j<span class="number">-1</span>];  <span class="comment">// 前缀回退,如果j本来就是0那没必要退，因为退无可退</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (s[i]==s[j]){</span><br><span class="line">                j++; </span><br><span class="line">            }</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>

<h3 id="模式串匹配"><a href="#模式串匹配" class="headerlink" title="模式串匹配"></a>模式串匹配</h3><p>在匹配的时候需要考虑三种情况。</p>
<ol>
<li>对应字符匹配</li>
<li>对应字符不匹配，模式串指针指向0</li>
<li>对应字符不匹配，模式串指针不指向0</li>
</ol>
<p>匹配就两者步进即可；不匹配，若是模式串指针指向0，就代表没有可以利用的匹配信息，文本串指针加一即可。若是不指向0，就代表有可以利用的信息，指针回退到next[指针位置 - 1]的值对应的位置即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">getNextTable</span>(needle);</span><br><span class="line">        <span class="type">int</span> ph=<span class="number">0</span>,pn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ph &lt; haystack.<span class="built_in">length</span>() &amp;&amp; pn != needle.<span class="built_in">length</span>()){</span><br><span class="line">            <span class="comment">// successfully match</span></span><br><span class="line">            <span class="keyword">if</span> (haystack[ph]==needle[pn]){</span><br><span class="line">                ph++,pn++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pn != <span class="number">0</span>){ <span class="comment">// pn = 0就退无可退了</span></span><br><span class="line">                <span class="comment">// match fail</span></span><br><span class="line">                pn = next[pn<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{ <span class="comment">// 如果pn=0并且匹配不上，那么没有可以利用的已经匹配的信息，直接从haystack的下一个位置匹配即可</span></span><br><span class="line">                ph++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (pn == needle.<span class="built_in">length</span>())  <span class="keyword">return</span> ph - pn;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>最后当模式串指针pn遍历完毕之后，ph - pn就是第一个匹配字符的下标。如果pn没有遍历完而是ph遍历完了，那代表文本串和模式串不匹配，输出-1。</p>
<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNextTable</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.length())</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i++){</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]){</span><br><span class="line">                j = next[j<span class="number">-1</span>];  <span class="comment">// 前缀回退,如果j本来就是0那没必要退，因为退无可退，那为什么不逐一退呢？为什么要退到nextTable</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (s[i]==s[j]){</span><br><span class="line">                j++; </span><br><span class="line">            }</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">getNextTable</span>(needle);</span><br><span class="line">        <span class="type">int</span> ph=<span class="number">0</span>,pn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ph &lt; haystack.<span class="built_in">length</span>() &amp;&amp; pn != needle.<span class="built_in">length</span>()){</span><br><span class="line">            <span class="comment">// successfully match</span></span><br><span class="line">            <span class="keyword">if</span> (haystack[ph]==needle[pn]){</span><br><span class="line">                ph++,pn++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pn != <span class="number">0</span>){ <span class="comment">// pn = 0就退无可退了</span></span><br><span class="line">                <span class="comment">// match fail</span></span><br><span class="line">                pn = next[pn<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{ <span class="comment">// 如果pn=0并且匹配不上，那么没有可以利用的已经匹配的信息，直接从haystack的下一个位置匹配即可</span></span><br><span class="line">                ph++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (pn == needle.<span class="built_in">length</span>())  <span class="keyword">return</span> ph - pn;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>


<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul>
<li>神中神回答j回退： <a href="https://blog.csdn.net/Leycaner/article/details/108301195?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~OPENSEARCH~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~OPENSEARCH~default-1.control">https://blog.csdn.net/Leycaner/article/details/108301195?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.control</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>ch2 像经济学家一样思考</title>
    <url>/2024/01/26/ch2%E5%83%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%AE%B6%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Thinking Like an Economist</p>
<h2 id="假设与模型"><a href="#假设与模型" class="headerlink" title="假设与模型"></a>假设与模型</h2><ul>
<li><p>假设：可以简化复杂的世界，使之更容易理解<br>Assumptions: simplify the complex world, make it easier to understand. </p>
</li>
<li><p>模型：一个复杂现象的高度简化<br>Model:  a highly simplified representation of a more complicated reality.</p>
</li>
</ul>
<h2 id="我们的第一个模型：循环流量图"><a href="#我们的第一个模型：循环流量图" class="headerlink" title="我们的第一个模型：循环流量图"></a>我们的第一个模型：循环流量图</h2><ul>
<li><p>循环流量图：一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型<br>The Circular-Flow Diagram:  a visual model of the economy, shows how dollars flow through markets among households and firms</p>
</li>
<li><p>生产要素：社会用来生产物品与劳务的资源，包括：劳动、土地 、资本（建筑物和用于生产的机器）等等。<br>Factors of production:  the resources the economy uses to produce goods &amp; services</p>
</li>
</ul>
<p><img src="/./img/%E5%BE%AA%E7%8E%AF%E6%B5%81%E9%87%8F%E5%9B%BE.png" alt="image-20240126214847836"></p>
<p>我觉得就是两个生产者消费者模型。</p>
<p>物品与服务市场上，企业生产，家庭消费。企业赚的💰通过工资、租金或利润的形式支出给家庭，家庭用这笔💰购买需要的物品或服务。</p>
<p>生产要素市场上，家庭是生产者，提供生产要素给企业以进行生产活动，企业是消费者，消费家庭提供的生产要素，并生产出对应的物品或服务。</p>
<h2 id="生产可能性边界-（PPF）"><a href="#生产可能性边界-（PPF）" class="headerlink" title="生产可能性边界 （PPF）"></a>生产可能性边界 （PPF）</h2><ul>
<li><p>表示在可得到的生产要素与生产技术既定时，一个经济体所能生产的两种产品数量的各种组合的图形<br>The Production Possibilities Frontier (PPF): a graph that shows the combinations of two goods the economy can possibly produce given the available resources and the available technology  </p>
</li>
<li><p>斜率（The slope）表示横坐标的机会成本。</p>
</li>
<li><p>如果一个经济从它可以获得的稀缺资源中获得了它能得到的，那么这种结果就称为有效率的。在生产可能性边界线内的各点的结果被成为无效率的，超出生产可能性边界的结果是不可能实现的。</p>
</li>
</ul>
<p><img src="/./img/%E7%94%9F%E4%BA%A7%E5%8F%AF%E8%83%BD%E6%80%A7%E8%BE%B9%E7%95%8C1.png" alt="image-20240126220409444"></p>
<p>生产可能性边界的移动：</p>
<p><img src="/./img/%E7%94%9F%E4%BA%A7%E5%8F%AF%E8%83%BD%E6%80%A7%E8%BE%B9%E7%95%8C%E7%A7%BB%E5%8A%A8.png" alt="image-20240126221050362"></p>
<h2 id="经济学研究分类"><a href="#经济学研究分类" class="headerlink" title="经济学研究分类"></a>经济学研究分类</h2><ul>
<li><p>微观经济学：研究家庭和企业如何做出决策，以及它们如何在市场上相互交易。<br>Microeconomics is the study of how households and firms make decisions and how they interact in markets.</p>
</li>
<li><p>宏观经济学：研究整体经济现象，包括通货膨胀，失业和经济增长。<br>Macroeconomics is the study of economy-wide phenomena, including inflation, unemployment, and economic growth.</p>
</li>
</ul>
<h2 id="作为政策顾问的经济学家"><a href="#作为政策顾问的经济学家" class="headerlink" title="作为政策顾问的经济学家"></a>作为政策顾问的经济学家</h2><ul>
<li><p>实证表述: 试图描述世界是什么样子的观点。<br>positive statements: claims that attempt to describe the world as it is.</p>
</li>
<li><p>规范表述: 试图描述世界应该是什么样子的观点。<br>normative statements：claims that attempt to prescribe how the world should be.</p>
</li>
</ul>
<h2 id="经济学家意见会产生分歧"><a href="#经济学家意见会产生分歧" class="headerlink" title="经济学家意见会产生分歧"></a>经济学家意见会产生分歧</h2><ul>
<li><p>经济学家经常提供相互矛盾的政策建议。<br>Economists often give conflicting policy advice.</p>
</li>
<li><p>他们可能对世界如何运行的不同实证理论的正确性看法不一致。<br>They sometimes disagree about the validity of alternative positive theories about the world. </p>
</li>
<li><p>他们可能有不同的价值观，因此对应该尝试实施什么样的政策有不同的规范观点。<br>They may have different values and, therefore, different normative views about what policy should try to accomplish.</p>
</li>
</ul>
<h2 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h2><ul>
<li>爱因斯坦说过：“所有科学不过是日常思考的不断完善而已。”</li>
<li>当经济学家试图去解释世界时，他们是科学家；当经济学家试图去改善世界时，他们是政策顾问。</li>
<li>经济学是一门容易的学科，但很少人能够在这个学科中做到出类拔萃，也许因为杰出的经济学家应该具有非常罕见的各种天赋的组合。在某种程度上，他应该是数学家，历史学家，政治家和哲学家。他必须了解符号并用文字将其表达出来。他必须根据一般性来深入思考特殊性，并在思绪奔放的同时触及抽象与具体。他必须<mark>根据过去、着眼未来而研究现在</mark>。他必须考虑到人性或人的制度的每一部分。他必须同时保持坚定而客观的情绪，要像艺术家一样超然而不流俗，但有时又要像政治家一样脚踏实地。</li>
</ul>
]]></content>
      <tags>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络中激活函数的选取</title>
    <url>/2023/04/26/Activate_function/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/Untitled.png" alt="Untitled"></p>
<hr>
<h2 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h2><p><img src="/img/Untitled1.png" alt="Untitled"></p>
<ul>
<li>当输出是<strong>0&#x2F;1值</strong>时采取Sigmoid Function</li>
<li>当输出是<strong>连续值</strong>，并且能取正负值时选取线性激活函数（也就是没有激活函数）</li>
<li>当输出是<strong>非负值</strong>时取ReLU激活函数：g(z) &#x3D; max(0,z)</li>
</ul>
<h2 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h2><p>隐藏层中最广泛使用的是<code>**ReLU函数**</code>，对比Sigmoid函数的原因如下：</p>
<ul>
<li>计算ReLU函数比Sigmoid函数快很多</li>
<li>计算梯度下降时速度和图像的斜率有关，因为sigmoid函数在图像两边的斜率太小，梯度要迭代很多次才能收敛。而RELU不会出现这个问题</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tf.keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line">model = Sequential([</span><br><span class="line">	Dense(units = <span class="number">25</span>, activation = <span class="string">&#x27;relu&#x27;</span>), <span class="comment"># layer1</span></span><br><span class="line">	Dense(units = <span class="number">15</span>, activation = <span class="string">&#x27;relu&#x27;</span>), <span class="comment"># layer2</span></span><br><span class="line">	Dense(units = <span class="number">1</span>, activation = <span class="string">&#x27;sigmoid&#x27;</span>) <span class="comment"># output layer</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>还有另外一些激活函数如<code>tanh(双曲正切函数</code>）, <code>LeakyRELU</code>, <code>swish</code> ,不过上述三个激活函数已经足以适用于大部分模型了</li>
<li>为什么要搞这些花里胡哨的激活函数，直接输出不好吗？就将一个模型的输出当作另一个模型的输入就好了呀？<strong>（激活函数的意义）</strong></li>
</ol>
<p><img src="/img/Untitled2.png" alt="Untitled"></p>
<p>可以看到如果隐藏层和输出层都用线性回归，那么本质还是线性回归，神经网络完全没有发挥作用。</p>
<p>如果隐藏层全是线性激活函数，输出层是sigmoid激活函数：</p>
<p><img src="/img/Untitled3.png" alt="Untitled"></p>
<p>那么这么多隐藏层其实就只做了一个线性回归，然后在输出层做了一个逻辑回归。所以这个神经网络和逻辑回归做的事情其实是一样的，并没有任何优化。所以普遍的规则是不要在隐藏层中使用线性激活函数（Q：那ReLU不是也只是把负数部分变为0了嘛？正数部分还是不变的呀？这样的非线性变换就可以说适合用作隐藏层的激活函数了？当输入变量全都是非负值那效果不还和线性激活函数一样的嘛？）</p>
<p>A: ReLU是通过<strong>wx</strong> + <strong>b</strong>的正负情况来控制<strong>是否让这部分unit输出发挥作用，从而达到不同unit负责不同的输入部分的目的（详情见下）</strong></p>
<ol>
<li>用<strong>非线性的激活函数</strong>的作用：</li>
</ol>
<p><img src="/img/Untitled4.png" alt="Untitled"></p>
<p>就是说输入很有可能是分段的，在每个转折点会有一个新的线性函数，比方说一条曲线分为三段，现在对其用神经网络做回归预测分析，第一层有三个units,ReLU函数可以使只有unit 0负责第一段的预测，就是说unit2和unit3经过w和b的调参可以使得当输入<strong>x</strong>位于第一段时，unit2和unit3算出来的z是负数，所以激活为0，这样就达到了不同unit控制不同输入段的作用，神经网络的特性就体现出来了。</p>
<h2 id="ReLU-Rectified-Linear-Unit"><a href="#ReLU-Rectified-Linear-Unit" class="headerlink" title="ReLU(Rectified Linear Unit)"></a>ReLU(Rectified Linear Unit)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">𝑎=𝑚𝑎𝑥(<span class="number">0</span>,𝑧)      <span class="comment"># ReLU function</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/Untitled5.png" alt="Untitled"></p>
<blockquote>
<p>The “off” or disable feature of the ReLU activation enables models to stitch together linear segments to model complex non-linear functions.</p>
</blockquote>
<p><img src="/img/Untitled6.png" alt="Untitled"></p>
<p><img src="/img/Untitled7.png" alt="Untitled"></p>
<p>因为对于已经预设好的unit0，由于ReLU函数的限制，只有当x0处于(0,1]之间时输出才不是0，所以unit0控制的就是曲线在(0,1]之间的输出；我们不想让unit1 和 unit3 控制[0,1]的预测，所以通过调整w1,b1,w2,b2可以实现当x &gt; 1时unit1开始控制，当x &gt; 2 时unit2开始控制。</p>
<p>综上，ReLU激活函数就是这样进行非线性的复杂规律的预测的</p>
]]></content>
      <tags>
        <tag>神经网络，深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ch3 相互依存性与贸易的好处</title>
    <url>/2024/01/31/ch3%E7%9B%B8%E4%BA%92%E4%BE%9D%E5%AD%98%E6%80%A7%E4%B8%8E%E8%B4%B8%E6%98%93%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Interdependence and the Gains from Trade</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>绝对优势：用比另一个生产者更少的投入生产某种物品的能力。<br>Absolute advantage:  the ability to produce a good using fewer inputs than another producer</p>
</li>
<li><p>比较优势：一个生产者以低于另一个生产者的机会成本生产一种物品的能力。<br>Comparative advantage:  the ability to produce a good at a lower opportunity cost than another producer</p>
</li>
<li><p>出口品：在国内生产而在国外销售的物品<br>Exports:  goods produced domestically and sold abroad</p>
</li>
<li><p>进口品：在国外生产而在国内销售的物品<br>Imports: goods produced abroad and sold domestically</p>
</li>
<li><p>相互依存和贸易可以使每个人都可以享有更多数量和品种的物品与劳务。<br>Interdependence and trade allow everyone to enjoy a greater quantity and variety of goods &amp; services.</p>
</li>
<li><p>当人们（或国家之间）能专门生产他们具有比较优势的产品时，经济“蛋糕”会变大，通过贸易也可以使每个人的状况变得更好。<br>When people—or countries—specialize in the goods in which they have a comparative advantage, the economic “pie” grows and trade can make everyone better off.</p>
</li>
</ul>
<h2 id="现代经济寓言"><a href="#现代经济寓言" class="headerlink" title="现代经济寓言"></a>现代经济寓言</h2><p>我们每天都在享用许多素不相识的人提供物品与服务，哪些为你提供物品与服务的人并不是出于仁慈而这样做。也没有某个政府机构命令他们满足你的欲望。</p>
<p>相反人们向你和其他消费者提供他们生产的物品和服务，是因为他们也从中得到了某种回报。<strong>这种相互依存自所以存在，是因为人们相互贸易。</strong></p>
<p>为了说明人们为什么选择在物品与服务上依靠其他人，以及这种选择如何改善了他们生活。</p>
<p>我们来看一个简单的经济。<strong>假设世界上只有两种物品牛肉和土豆，而且世界上只有两个人</strong>：名叫 Ruby 的牧牛人和名叫 Frank 的种各种土豆农民。他们每个人既爱吃牛肉，又爱吃土豆。</p>
<p><strong>如果 Ruby 只能生产牛肉，Frank 只能生产土豆，贸易好处显而易见</strong>。在这种情况下 Ruby 和 Frank 可能选择 “老死不相往来”，在吃了几个月烤牛人、煮牛肉、炸牛肉和烧牛肉之后 Ruby 确信自给自足并不像想象中那么惬意。一直吃土豆泥、炸土豆、烤土豆和土豆片的 Frank 也同意 Ruby 看法。很明显贸易使他们享用更多的食物品种。</p>
<p><strong>但如果 Frank 与 Ruby 都能生产对方生产物品，只是成本相对较高，那么这种好处也是一样的。</strong>例如，假定 Ruby 可以种土豆，只是她的土地非常不适于种土豆。同样假定 Frank 也能养牛，只是他不擅于养牛和生产牛肉。在这种情况下很容易看出，Frank 和 Ruby 可以专门从事他们最擅长的活动并从相互交易中获益。</p>
<p><strong>但是，当某个人在生产每种物品上都较为擅长时，贸易的好处就不那么明显。</strong>例如，假定 Ruby 在生产牛肉和土豆上都优于 Frank。在这种情况下，Ruby 应该选择字给自足吗？或者她还有理由去和 Frank 进行交易吗。为了回答这个问题，我们需要更仔细研究影响这种决策的因素。</p>
<p>假如 Frank 和 Ruby 每人每天工作 8 小时，并可以把时间用于种土豆、养牛或者两种组合上。如表 1，<strong>Frank 用 15 分钟生产 1 盎司土豆，用 60 分钟生产 1 盎司牛肉。Ruby 在这两种活动中生产效率都更高，用 10 分钟生产 1 盎司土豆，用 20 分钟生产 1 盎司牛肉。</strong></p>
<p>Ruby 在养牛和种土豆方面都更精通，<strong>Frank 怎么能专门从事他最擅长的工作呢？</strong></p>
<p>Frank 似乎做什么都不是最擅长的。为了解开这个疑惑，我们考虑下这个问题：在这个例子中，谁能以较低的成本生产土豆？时 Frank 还是 Ruby？有两种可能答案，这两种答案包含着解决我们困惑的方法，它们是理解贸易所带来好处的关键。</p>
<p><img src="https://sm.ms/image/xo6dPI1M5VZ3wHh" alt="img1"></p>
<p><img src="https://sm.ms/image/rchWTQbVMUmOvGS" alt="img2"></p>
<h2 id="衡量标准：绝对优势"><a href="#衡量标准：绝对优势" class="headerlink" title="衡量标准：绝对优势"></a>衡量标准：绝对优势</h2><p>当比较一个人、一个企业或一个国家与另一个人、另一个企业或另一个国家的生产率时，经济学家用绝对优势这个术语。<strong>如果生产者生产一种物品所投入较少，就可以说改生产者生产这种物品上有绝对优势</strong>。</p>
<p>在我们的例子中，时间是唯一投入，因此我们可以通过考察生产者所需要的时间来确定绝对优势。Ruby 无论在生产土豆还是生产牛肉上都有绝对优势，因为她生产 1 单位这两种物品需要时间都少于 Frank。</p>
<p><strong>因此，如果我们用投入量来衡量成本，则 Ruby 生产的土豆成本较低。</strong></p>
<h2 id="衡量标准：比较优势"><a href="#衡量标准：比较优势" class="headerlink" title="衡量标准：比较优势"></a>衡量标准：比较优势</h2><p>还可以用另外一种方法考察生产土豆的成本，我们可以不比较所需要的投入，而是比较机会成本。<strong>某个东西的机会成本是为了得到它而放弃的东西</strong>。</p>
<p>我们先考虑 Ruby 机会成本，她生产 1 盎司土豆需要工作 10 分钟。当 Ruby 把 10 分钟用于生产土豆时，她用于生产牛肉的时间就需要减少 10 分钟。由于 Ruby 生产 1 盎司牛肉需要 20 分钟，所以工作 10 分钟将生产 1&#x2F;2 盎司牛肉。这样，Ruby 生产 1 盎司土豆的机会成本是 1&#x2F;2 盎司牛肉。</p>
<p>现在来考虑 Frank 的机会成本，他生产 1 盎司土豆需要 15 分钟。由于他生产 1 盎司牛肉需要 60 分钟，所以工作 15 分钟将生产 1&#x2F;4 盎司牛肉。这样，Frank 生产 1 盎司土豆的机会成本是 1&#x2F;4 盎司牛肉。</p>
<p><strong>如果一个生产者在生产 X 物品时放弃了较少的其他物品，即生产 X 物品的机会成本较小，我们就可以说，他在生产该物品上具有比较优势。</strong></p>
<p>在我们例子中，Frank 生产土豆的机会成本低于 Ruby:Frank 生产 1 盎司土豆的机会成本只是 1&#x2F;4 盎司牛肉，而 Ruby 生产 1 盎司土豆的机会成本是 1&#x2F;2 盎司牛肉。相反，Ruby 生产牛肉的机会成本低于 Frank：Ruby 生产 1 盎司牛肉的机会成本是 2 盎司土豆，而 Frank 生产 1 盎司牛肉的机会成本是 4 盎司土豆。<strong>因此，Frank 在种植土豆上有比较优势，而 Ruby 在生产牛肉上有比较优势。</strong></p>
<p>尽管一个人可能在两种物品的生产上都具有绝对优势（正如这个例子 Ruby 那样），但一个人却不可能在两种物品的生产上都具有比较优势。<strong>因为一种物品的机会成本是另外一种物品机会成本的倒数，如果一个人生产一种物品的机会成本较高，那么他生产另外一种物品的机会成本必然较低。</strong></p>
<p><strong>当每个人都专门生产自己有比较优势的物品时，经济的总产量就增加了，经济蛋糕的变大可用于改善每个人的状况。</strong></p>
<p>在我们例子中 Frank 用更多时间种土豆，而 Ruby 用更多的时间生产牛肉。结果土豆的总产量从 40 盎司增加到 44 盎司，牛肉的总产量从 16 盎司增加到 18 盎司。Frank 和 Ruby 分享这种产量增加的好处。</p>
<p><strong>现在牧牛人 Ruby 和农民 Frank 故事的寓意应该清楚了，贸易可以使社会的每个人都获益，因为它使人吗可以专门从事他们具有比较优势的活动</strong></p>
]]></content>
      <tags>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>ch4 供给与需求的市场力量</title>
    <url>/2024/02/02/ch4%E4%BE%9B%E7%BB%99%E4%B8%8E%E9%9C%80%E6%B1%82%E7%9A%84%E5%B8%82%E5%9C%BA%E5%8A%9B%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>The Market Forces of Supply and Demand</p>
</blockquote>
<h2 id="市场与竞争"><a href="#市场与竞争" class="headerlink" title="市场与竞争"></a>市场与竞争</h2><ul>
<li>市场：某种物品或劳务的一群买者与卖者。<br>A market is a group of buyers and sellers of a particular product.</li>
<li>竞争市场：有许多买者与卖者，以至于每个人对市场价格的影响都微乎其微的市场。<br>A competitive market is one with many buyers and sellers, each has a negligible effect on price</li>
<li>完全竞争市场：可供销售的物品是完全相同的，并且买者和卖者众多，没有任何一个买者或者卖者能决定市场价格。</li>
<li>垄断者：只有一个卖者，这个卖者决定市场。</li>
</ul>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li><p>物品的需求量： 是买者<strong>愿意并且能够购买</strong>的一种物品的数量。<br>The quantity demanded of any good is the amount of the good that buyers are willing and able to purchase.</p>
</li>
<li><p>需求表： 表示一种物品的价格与需求量之间关系的表格。<br>Demand schedule:a table that shows the relationship between the price of a good and the quantity demanded</p>
</li>
</ul>
<p>​	<img src="/./img/%E9%9C%80%E6%B1%82%E8%A1%A8.png" alt="image-20240202171746655"></p>
<ul>
<li>需求曲线<br>demand curve: a graph of the relationship between the price of a good and the quantity demanded</li>
</ul>
<p><img src="/./img/%E9%9C%80%E6%B1%82%E6%9B%B2%E7%BA%BF.png" alt="image-20240202171802655"></p>
<ul>
<li>市场需求量是<strong>所有买者</strong>在每一价格水平下需求量的总和。<br>The quantity demanded in the market is the sum of the quantities demanded by all buyers at each price.</li>
</ul>
<p><img src="/./img/%E5%B8%82%E5%9C%BA%E9%9C%80%E6%B1%82.png" alt="image-20240202171838849"></p>
<ul>
<li><p>正常物品：在其他条件相同时，收入增加引起需求量增加的物品。比如，收入增加引起打车需求增多。<br>normal good：a good for which, other things equal, an increase in income leads to an increase in demand</p>
</li>
<li><p>低档物品：在其他条件相同时，收入增加引起需求量减少的物品。例如，收入增加引起坐公交需求减少。<br>inferior good： a good for which, other things equal, an increase in income leads to a decrease in demand</p>
</li>
<li><p>替代品：一种物品价格上升引起另一种物品需求量增加的两种物品。例如，瑞幸和星巴克。<br>Substitutes： two goods for which an increase in the price of one leads to an increase in the demand for the other</p>
</li>
<li><p>互补品：一种物品价格上升引起另一种物品需求量减少的两种物品。例如，iphone手机和手机壳。<br>Complements：two goods for which an increase in the price of one leads to a decrease in the demand for the other</p>
</li>
</ul>
<h2 id="供给"><a href="#供给" class="headerlink" title="供给"></a>供给</h2><ul>
<li><p>供给量：卖者愿意并且能够出售的一种物品的数量。<br>quantity supplied： the amount of a good that sellers are willing and able to sell</p>
</li>
<li><p>供给表：表示一种物品的价格与供给量之间关系的表格。<br>supply schedule：a table that shows the relationship  between the price of a good and the quantity supplied</p>
</li>
</ul>
<p><img src="/./img/%E4%BE%9B%E7%BB%99%E8%A1%A8.png" alt="image-20240202222517402"></p>
<ul>
<li>供给曲线：<br>supply curve：a graph of the relationship between the price of a good and the quantity supplied</li>
</ul>
<p><img src="/./img/%E4%BE%9B%E7%BB%99%E6%9B%B2%E7%BA%BF.png" alt="image-20240202222616248"></p>
<ul>
<li>市场供给量是在每种价格水平下所有卖者的供给量之和。<br>The quantity supplied in the market is the sum of the quantities supplied by all sellers at each price.</li>
</ul>
<p><img src="/./img/%E5%B8%82%E5%9C%BA%E4%BE%9B%E7%BB%99.png" alt="image-20240202222644021"></p>
<h2 id="均衡"><a href="#均衡" class="headerlink" title="均衡"></a>均衡</h2><ul>
<li><p>均衡价格：使供给与需求平衡的价格<br>Equilibrium price: the price that equates quantity supplied with quantity demanded</p>
</li>
<li><p>均衡数量：均衡价格下的供给量与需求量<br>Equilibrium quantity: the quantity supplied and quantity demanded at the equilibrium price</p>
</li>
</ul>
<p><img src="/./img/%E5%9D%87%E8%A1%A1.png" alt="image-20240202222753720"></p>
<ul>
<li><p>过剩 (超额供给):供给量大于需求量的状态<br>Surplus (a.k.a. excess supply): when quantity supplied is greater than quantity demanded</p>
</li>
<li><p>短缺（超额需求）:需求量大于供给量的状态<br>Shortage (a.k.a. excess demand): when quantity demanded is greater than quantity supplied</p>
</li>
<li><p>需求定理：认为在其他条件不变时，一种物品的价格上升，该物品的需求量会减少的观点。<br>Law of demand:  the claim that the quantity demanded of a good falls when the price of the good rises, other things equal</p>
</li>
<li><p>供给定理：认为在其他条件不变时，一种物品价格上升，该物品供给量增加的观点。<br>Law of supply:  the claim that the quantity supplied of a good rises when the price of the good rises, other things equal</p>
</li>
</ul>
<h2 id="曲线移动"><a href="#曲线移动" class="headerlink" title="曲线移动"></a>曲线移动</h2><ol>
<li>﻿﻿﻿确定该事件是使供给曲线移动还是使需求曲线移动（还是使两者都移动）。</li>
<li>﻿﻿确定曲线移动的方向。</li>
<li>﻿﻿﻿用供求图说明这种移动如何改变均衡价格和均衡数量。</li>
</ol>
<p>举例：若台风天使得糖的价格上涨，并且夏季炎热。分析出的均衡情况。</p>
<p><img src="/./img/%E6%96%B0%E5%9D%87%E8%A1%A1.png" alt="image-20240202223353822"></p>
]]></content>
      <tags>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>ch1 经济学的十大原理</title>
    <url>/2024/01/25/ch1%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E5%8D%81%E5%A4%A7%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Tradeoff, Cost, Margin, Incentive.</p>
<p>Trade, Market, Government.</p>
<p>Production, Money, Inflation&amp;Unemployment</p>
</blockquote>
<h2 id="经济学研究什么问题"><a href="#经济学研究什么问题" class="headerlink" title="经济学研究什么问题?"></a>经济学研究什么问题?</h2><ul>
<li><p>稀缺性:社会资源的有限性</p>
<p><strong>Scarcity</strong>:  the limited nature of society’s resources</p>
</li>
<li><p>经济学: 研究社会如何管理自己的稀缺资源<br><strong>Economics</strong>:  the study of how society manages its scarce resources</p>
</li>
</ul>
<p>经济学研究三个问题：</p>
<ol>
<li>人们如何做出决策</li>
<li>人们如何相互影响</li>
<li>整体经济如何运行</li>
</ol>
<p>其中前两个是微观经济学，最后一个是宏观经济学。<mark>即使是国家与国家之间的贸易，也是微观经济学的范畴。</mark></p>
<h2 id="人们如何做出决策？"><a href="#人们如何做出决策？" class="headerlink" title="人们如何做出决策？"></a>人们如何做出决策？</h2><h3 id="原理-1-人们面临权衡取舍"><a href="#原理-1-人们面临权衡取舍" class="headerlink" title="原理 1:  人们面临权衡取舍"></a>原理 1:  人们面临权衡取舍</h3><p>PRINCIPLE #1:  People Face <mark>Tradeoffs</mark></p>
<p>“大炮与黄油”的例子。</p>
<ul>
<li>效率: 社会能从其稀缺资源中得到的最大利益，蛋糕的大小<br>Efficiency:  the property of society getting the most it can from its scarce resources</li>
<li>平等: 经济成果在社会成员中平均分配，蛋糕怎么分<br>Equality:  the property of distributing economic prosperity uniformly among society’s members<br>（控制污染会使收入下降）</li>
</ul>
<h3 id="原理-2-某种东西的成本是为了得到它所放弃的东西"><a href="#原理-2-某种东西的成本是为了得到它所放弃的东西" class="headerlink" title="原理 2:  某种东西的成本是为了得到它所放弃的东西"></a>原理 2:  某种东西的成本是为了得到它所放弃的东西</h3><p>PRINCIPLE #2: The <mark>Cost</mark> of Something Is  What You Give Up to Get It</p>
<ul>
<li>机会成本：是为了得到这种东西所放弃的东西<br>opportunity cost： whatever must be given up to obtain some item.</li>
</ul>
<h3 id="原理-3-理性人考虑边际量"><a href="#原理-3-理性人考虑边际量" class="headerlink" title="原理 3:  理性人考虑边际量"></a>原理 3:  理性人考虑边际量</h3><p>PRINCIPLE #3:  Rational people Think at the <mark>Margin</mark></p>
<ul>
<li>理性人：系统而有目的地尽最大努力实现其目标的人<br>Rational people：people who systematically and purposefully do the best they can to achieve their objectives<br>（理性人通过比较成本与利益的边际变动来做出决策）</li>
<li>边际变动：对现有行动计划的微小增量调整<br>marginal changes：a small incremental adjustments to a plan of action.<br>（人们对于任何一种物品的支付意愿基于获得一单位的边界收益）<br>（当且仅当边界收益大于边界成本时，理性人就会行动)</li>
</ul>
<h3 id="原理-4-人们会对激励做出反应"><a href="#原理-4-人们会对激励做出反应" class="headerlink" title="原理 4:  人们会对激励做出反应"></a>原理 4:  人们会对激励做出反应</h3><p>PRINCIPLE #4: People Respond to <mark>Incentives</mark></p>
<ul>
<li>激励：引起一个人做出某种行为的某种东西，诸如惩罚或奖励的预期<br>Incentive: something that induces a person to act。<br>（有人认为安全带减少了谨慎开车的收益，导致车祸数量增加，结果是司机的死亡人数变动很小，行人的死亡人数增加了）<br>（05-08年石油价格上涨与强劲的全球以及中国的增长有关，08开始的金融危机又使得价格下跌）</li>
</ul>
<h2 id="人们如何相互影响？"><a href="#人们如何相互影响？" class="headerlink" title="人们如何相互影响？"></a>人们如何相互影响？</h2><h3 id="原理-5-贸易可以使每个人的状况都变得更好"><a href="#原理-5-贸易可以使每个人的状况都变得更好" class="headerlink" title="原理 5:  贸易可以使每个人的状况都变得更好"></a>原理 5:  贸易可以使每个人的状况都变得更好</h3><p>PRINCIPLE #5: <mark>Trade</mark> Can Make Everyone Better Off<br>（经济中每个家庭都在与其他竞争）</p>
<h3 id="原理-6-市场通常是组织经济活动的一种好方法"><a href="#原理-6-市场通常是组织经济活动的一种好方法" class="headerlink" title="原理 6:  市场通常是组织经济活动的一种好方法"></a>原理 6:  市场通常是组织经济活动的一种好方法</h3><p>PRINCIPLE #6:  <mark>Markets</mark> Are Usually A Good Way to Organize Economic Activity</p>
<ul>
<li>市场经济：许多企业和家庭在物品和劳务市场上相互交易，通过他们的分散决策来配置资源的经济<br>market economy：an economy that allocates resources through the decentralized decisions of many households and firms as they interact in markets for goods and services.  </li>
<li>亚当.斯密在《国富论》中的著名观察结果：<br>家庭和企业仿佛被一只“看不见的手”所指引，在市场上相互交易，并增进整体经济的福利<br>“看不见的手”通过价格体系来发挥作用:<ul>
<li>买者与卖者之间的相互作用(供求关系)决定市场价格</li>
<li>每个价格即反映了物品对于买者的价值，也反映了生产物品的成本</li>
<li>在许多情况下，价格引导自利的家庭与企业做出使社会经济福利最大化的决策<br>（政府税收扭曲了价格，也扭曲了家庭和企业的决策）</li>
</ul>
</li>
</ul>
<h3 id="原理-7-政府有时可以改善市场结果"><a href="#原理-7-政府有时可以改善市场结果" class="headerlink" title="原理 7:  政府有时可以改善市场结果"></a>原理 7:  政府有时可以改善市场结果</h3><p>PRINCIPLE #7:<mark>Governments</mark> Can Sometimes Improve Market Outcomes</p>
<ul>
<li>产权：个人拥有并控制稀缺资源的能力<br>Property rights: the ability of an individual to own and exercise control over scarce resources.<br>（只有政府在实施规则并维持对市场经济至关重要的制度，价格才会起作用，市场经济需要产权）</li>
</ul>
<p>（政府干预经济的目标有两类：效率和平等）</p>
<ul>
<li><p>市场失灵：市场本身不能有效配置资源的情况<br>Market failure:  a situation in which a market left on its own fails to allocate resources efficiently<br>导致市场失灵的原因</p>
<ul>
<li><p>外部性：生产或消费一个物品影响到旁观者的福利（比如：污染）<br>  Externalities:  the uncompensated impact of one person’s actions on the well-being of a bystander.</p>
</li>
<li><p>市场势力：单个买者或卖者有能显著影响市场价格的能力（比如，垄断）<br>Market power：the ability of a single economic actor (or small group of actors) to have a substantial influence on market price (e.g. monopoly)</p>
</li>
</ul>
</li>
</ul>
<h2 id="整体经济如何运行？"><a href="#整体经济如何运行？" class="headerlink" title="整体经济如何运行？"></a>整体经济如何运行？</h2><h3 id="原理-8-一国的生活水平取决于它生产物品与服务的能力"><a href="#原理-8-一国的生活水平取决于它生产物品与服务的能力" class="headerlink" title="原理 8:  一国的生活水平取决于它生产物品与服务的能力"></a>原理 8:  一国的生活水平取决于它生产物品与服务的能力</h3><p>PRINCIPLE #8: A Country’s Standard of Living Depends on Its Ability to <mark>Produce Goods &amp; Services</mark></p>
<ul>
<li>生产率：即每一单位劳动投入所生产的物品与劳务数量<br>Productivity：the amount of goods and services produced from each unit of labor input<br>（生产率决定了平均收入的增长率）<br>（生产率取决于设备，劳动者的技能以及可用的技术）<br>（其它因素（比如，工会组织，国外的竞争）对于生活水平的影响远远小于生产率）</li>
</ul>
<h3 id="原理-9-当政府发行了过多货币时，物价上升"><a href="#原理-9-当政府发行了过多货币时，物价上升" class="headerlink" title="原理 9:  当政府发行了过多货币时，物价上升"></a>原理 9:  当政府发行了过多货币时，物价上升</h3><p>PRINCIPLE #9: Prices Rise When the Government Prints Too Much <mark>Money</mark></p>
<ul>
<li>通货膨胀：经济中物价总水平的上升<br>Inflation:  an increase in the overall level of prices in the economy.</li>
</ul>
<h3 id="原理-10-社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#原理-10-社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="原理 10:  社会面临通货膨胀与失业之间的短期权衡取舍"></a>原理 10:  社会面临通货膨胀与失业之间的短期权衡取舍</h3><p>PRINCIPLE #10: Society Faces a Short-run Tradeoff Between <mark>Inflation and Unemployment</mark></p>
<ul>
<li>货币量增加增加了支付能力，更多的支付导致物价上涨，物价上涨但同时刺激企业雇佣更多的工人，失业率会下降<br>（短期1-2年内，许多经济政策朝相反的方向推动通货膨胀与失业）</li>
<li>经济周期：就业和生产等经济活动的波动<br>Business cycle:  fluctuations in economic activity, such as employment and production.</li>
</ul>
<h3 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h3><ul>
<li><p>“他追求自己的利益，往往使他能比在真正出于本意的情况下更能促进社会的利益。”经济参与者受利己心的驱动，市场这只看不见的手指引这种利己心去促进社会的整体福利。”每个人出于利己的目的去工作，仍然可以产生合意的社会结果”。</p>
</li>
<li><p>经济学中的“<strong>破窗谬论</strong>”：</p>
<p>举个例子，假设在市场完全饱和的情况下，一个人砸碎了理发店的玻璃窗，这一行为虽然对社会造成了破坏，但是理发师的不幸却是社会的福音，它将为玻璃 生产商 制造商 机，生产商拿到钱后又去购买其他生产商的产品。在 乘数效应 的作用下，他给社会造成的损害只是一次性的，可是给社会带来的机会却是连锁性的，于是得出结论:打碎一块玻璃，提供了无数金钱和就业机会，得大于失。<br>这个理论乍一看来，似乎确实很有道理。在市场处于饱和的状态下，供需大体一致，不存在新的需求，也不存在新的供给，若 生产能力 增加，那就意味着 生产过剩 ，市场对 资源的配置 就无法达到 帕雷托最优 状态。而此时只要让物品的占有者遭受一次损失，为了弥补这个损失，就会产生对商品新的需求，这个需求缺口就能带来供给的增加，重新使得供需达到平衡。</p>
<blockquote>
<p>为何称之为谬论？</p>
</blockquote>
</li>
</ul>
<ol>
<li>首先其前提假设在现实中是不存在的。</li>
<li>其次灾难破坏可以创造需求，但是不能促进 经济发展 ，甚至都谈不上“ 零和博弈 ”。</li>
<li>再次“以破坏来创造需求”是一种为了获得经济增量而牺牲存量的愚蠢行为。破坏创造需求这种行为，会造成有限资源的浪费，产生“双重成本”:一个是 机会成本 ，这部分有限的资源本来可以挪作他处，用来创造更多的财富。另一个是毁灭成本，就是对已有财富的破坏形成的巨大损失。</li>
</ol>
<p>“破窗谬论”之一，在于它忽视了这种“破窗”引起的 经济活动 是以 社会资源 的浪费和生命财产的损失为代价的。“破窗谬论”之二，在于盲目乐观地臆测破窗后增加的 消费行为 。被偷后，本来 收入 并不丰厚的你可能这个月就不会去买衣服了，而且因为担心再次遭遇小偷，你会减少外出的 次数 ，你的 消费 支出 相反少了。小偷的猖獗给人们 心理 造成了极大的恐惧和不安， 政府 就要加大力量，投入更多的 财力 来 整顿 治安，而本来这些钱可以用到建设上的。</p>
<p>破窗谬论的范围再扩大一些，就是一些人会觉得战争或者灾难会给国家带来好处，因为战争和灾难会把一些 社会资源 破坏掉，这时会增加 社会 的需求。原理其实一样，因为战争和灾难造成人们的需求，只不过是把人们原来本来就有的其他需求转移到这些地方上。把战争期间几年人们得不到的需求，转移到战后的几年。实际对整个社会并没有好处。战争和灾难会使得 生产能力 降低，也降低了人们的 支付能力 ，最终反而使得 总需求 会减少。</p>
<ul>
<li>学经济学，一定要 说A想到B,C,D….要有批判性思维，试想各种可能性</li>
</ul>
]]></content>
      <tags>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>Day8 哈希表Part3</title>
    <url>/2024/01/30/Day8%20%E5%93%88%E5%B8%8C%E8%A1%A8Part3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>哈希表部分的最后一节，三数之和比较难，而且用哈希表实现效率不高，使用双指针可以获得较好的时间效率。</p>
</blockquote>
<h2 id="1-赎金信"><a href="#1-赎金信" class="headerlink" title="1 赎金信"></a>1 赎金信</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p><strong>注意：</strong></p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<h3 id="1-2-思路解析"><a href="#1-2-思路解析" class="headerlink" title="1.2 思路解析"></a>1.2 思路解析</h3><p>通过构造字符和出现次数的<code>unordered_map</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造字母-次数的映射键值对</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:magazine)</span><br><span class="line">            m[c]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:ransomNote)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--m[c] &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-三数之和"><a href="#2-三数之和" class="headerlink" title="2 三数之和"></a>2 三数之和</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h3 id="2-2-思路解析"><a href="#2-2-思路解析" class="headerlink" title="2.2 思路解析"></a>2.2 思路解析</h3><p>这个题首先得知道怎么找全三个和为0的数，首先可以用减治的思想化为定值 + 两数之和的问题，之前我们已经用时间复杂度为O($n$)的方法求解过两数之和的问题了，加上固定指针的最外层循环，就可以实现时间复杂度为$O(n^2)$的算法了。</p>
<p>但是问题来了，找出全部的三元组之后要如何去重呢？</p>
<p>我想到的方法是利用set的模版以及自动去重的特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSum</span>(<span class="type">int</span> target, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> f = s.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (f == s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span> * target, *f, nums[i]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ansVec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</span></span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; t = <span class="built_in">twoSum</span>(<span class="number">-1</span> * nums[i], nums, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vec:t)&#123;</span><br><span class="line">                ans.<span class="built_in">insert</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ansVec.<span class="built_in">reserve</span>(ans.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vec:ans)&#123;</span><br><span class="line">                ansVec.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ansVec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这种方法虽然正确，但是提交的时候却超时了，我们加上这一句剪枝操作试试。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>加上之后就可以顺利通过测试了，但是所用的时间和空间还是太大。分析其中的原因，虽然算法整体的时间复杂度是$O(n^2)$，但是建立哈希表的时间太慢，而这是使用哈希方法不可避免的问题。</p>
<p>那有没有比哈希表更高效的方法呢？</p>
<p>有的，答案就是使用<mark>双指针</mark>！</p>
<p>哈希表实现中，确定好第一个指针之后，每移动一次第二个指针都会调用哈希函数在红黑树中建立一个节点。这在时间和空间上都会有加大的开销。于是我们想，<mark>如果能够用两个指针相反方向遍历剩余数组，找到合适的target值，这样时间和空间开销就会小很多了！</mark></p>
<p>于是我们构造两个指针，left和right指针来进行遍历。<mark>如果三个数加起来是负数的话，left指针就往右移；如果加起来是正数的话，right指针就往左移。</mark>然后再加上去重操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[l] + nums[r] &lt; <span class="number">0</span>)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[l] + nums[r] &gt; <span class="number">0</span>)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] == nums[l<span class="number">-1</span>] &amp;&amp; r != nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[r] == nums[r+<span class="number">1</span>])   &#123;</span><br><span class="line">                    l++;r--;  <span class="comment">// 如果上次push_back时l++与r--的结果还是一样的，那么跳过这个结果</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[l++],nums[r--]&#125;); <span class="comment">// while循环还要进行下去，因为可能还有三元组没有找到，所以用continue</span></span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用这种方法，时间复杂度就很小，算法性能提升了很多。</p>
]]></content>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/26/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>QThread&amp;QTimer讲解和实现</title>
    <url>/2023/04/30/QThread%20%E4%B8%8E%20QTimer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>最近在做HCI的第一个作业语音识别和操作系统课设时需要用到<strong>pyqt5</strong>做前端界面，而且这两者都涉及多线程，可是操作系统刚刚学完线程的理论🥲，所以又得发扬本专业的优良传统：自学了。为了加深自己的记忆，也为了能给后来者提供参考，现在总结一下做项目需要用到的基本的多线程知识。</p>
</blockquote>
<h2 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h2><p>多线程的目的：</p>
<blockquote>
<p> Sometimes you can divide your programs into several smaller <strong>subprograms</strong>, or <strong>tasks</strong>, that you can run in several threads. This might make your programs faster, or it might help you improve the user experience by preventing your programs from freezing while executing long-running tasks.</p>
</blockquote>
<p>多线程程序通常比单线程程序更难编写、维护和调试，因为涉及到在线程之间共享资源、同步数据访问和协调线程执行方面的复杂性。这可能会导致以下几个问题：</p>
<ul>
<li><strong>竞争条件</strong>：当应用程序的行为由于事件的不可预测顺序而变得不确定时，就会发生竞争条件。这通常是两个或多个线程在没有正确同步的情况下访问共享资源的结果。例如，如果从不同的线程中读取和写入内存，如果读取和写入操作的顺序不正确，则可能会导致竞争条件。</li>
<li><strong>死锁</strong>：当线程无限期地等待锁定资源被释放时，就会发生死锁。例如，如果一个线程锁定一个资源并在使用后不解锁它，则其他线程将无法使用该资源并会无限期地等待。死锁也可能发生在线程A等待线程B释放一个资源，而线程B又等待线程A释放另一个资源的情况下。两个线程将都无限期地等待。</li>
<li><strong>活锁</strong>：当两个或多个线程在响应彼此的动作时反复进行时，就会发生活锁。活锁线程无法在其特定任务上取得进一步进展，因为它们忙于彼此响应。然而，它们没有被阻塞或死亡。</li>
<li><strong>饥饿</strong>：当一个进程永远无法获得完成工作所需的资源时，就会发生饥饿。例如，如果你有一个无法获得CPU时间访问的进程，那么该进程就会饥饿于CPU时间，无法完成其工作。</li>
</ul>
<p>Qt，因此也包括PyQt，提供了自己的基础设施来使用<code>QThread</code>创建多线程应用程序。PyQt应用程序可以有两种不同的线程类型：</p>
<ol>
<li>主线程</li>
<li>工作线程</li>
</ol>
<p>应用程序的主线程始终存在，这是应用程序和其GUI运行的地方。另一方面，<strong>工作线程</strong>的存在取决于应用程序的处理需求。例如，如果您的应用程序通常运行需要很长时间才能完成的重型任务，那么您可能需要工作线程来运行这些任务并避免冻结应用程序的GUI。</p>
<p>在PyQt应用程序中，执行的主线程也称为<strong>GUI线程</strong>，因为它处理所有小部件和其他GUI组件。当您运行应用程序时，Python会启动这个线程。在您在<code>QApplication</code>对象上调用<code>.exec()</code>后，应用程序的<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qcoreapplication.html#the-event-loop-and-event-handling">事件循环</a>在该线程中运行。该线程处理您的窗口、对话框，以及与主机操作系统的通信。</p>
<p>重要的是要注意，您必须在GUI线程中创建和更新所有小部件。然而，您可以在工作线程中执行其他长时间运行的任务，并使用它们的结果来提供应用程序的GUI组件。这意味着GUI组件将作为消费者，从执行实际工作的线程中获得信息。</p>
<p>您可以在PyQt应用程序中创建尽可能多的工作线程，工作线程是次要的执行线程，您可以使用它们来卸载主线程中的长时间运行的任务并防止GUI冻结。</p>
<p>您可以使用<code>QThread</code>创建工作线程。每个工作线程都可以拥有自己的事件循环，并支持PyQt的<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/signals_slots.html">信号和槽机制</a>与主线程进行通信。如果您在特定的线程中创建任何从<a href="https://doc.qt.io/qt-5/qobject.html"><code>QObject</code></a>类继承的对象，则该对象被认为<strong>属于</strong>或具有该线程的<strong>关联性</strong>。其子对象也必须属于相同的线程。</p>
<p><code>QThread</code>本身并不是一个线程，而是对操作系统线程的封装。真正的线程对象是在调用<a href="https://doc.qt.io/qt-5/qthread.html#start"><code>QThread.start()</code></a>时创建的。</p>
<p><code>QThread</code>提供了一个高级应用程序编程接口（<a href="https://en.wikipedia.org/wiki/API">API</a>）来管理线程。这个API包括一些信号，比如<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#started"><code>.started()</code></a>和<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#finished"><code>.finished()</code></a>，在线程开始和结束时发出。它还包括一些方法和槽，比如<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#start"><code>.start()</code></a>、<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#wait"><code>.wait()</code></a>、<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#exit"><code>.exit()</code></a>、<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#quit"><code>.quit()</code></a>、<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#isFinished"><code>.isFinished()</code></a>和<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qthread.html#isRunning"><code>.isRunning()</code></a>。</p>
<p>与任何其他线程解决方案一样，使用<code>QThread</code>时必须保护数据和资源免受<strong>并发</strong>或同时访问。否则，您将面临许多问题，包括死锁、数据损坏等。</p>
<h2 id="QThread-OR-threading"><a href="#QThread-OR-threading" class="headerlink" title="QThread OR threading?"></a>QThread OR threading?</h2><p>QThread是pyqt5中用来管理多线程的模块。</p>
<p><img src="https://doc.qt.io/qtforpython-5/_images/inheritance-92d42ba4c526f8f37c94ef096bf68f0131ef5800.png" alt="Inheritance diagram of PySide2.QtCore.QThread"></p>
<p>在Python中使用线程时，您会发现Python<a href="https://docs.python.org/3/library/index.html">标准库</a>提供了一个具有一致性和强大的解决方案，即<a href="https://docs.python.org/3/library/threading.html#module-threading"><code>threading</code></a>模块。该模块提供了一个高级API，用于在Python中进行多线程编程。</p>
<p>通常，在Python应用程序中使用<code>threading</code>。然而，如果您使用PyQt来构建使用Python的GUI应用程序，则有另一种选择。PyQt提供了一个完整、完全集成的高级API，用于进行多线程编程。</p>
<p>您可能会想知道，在我的PyQt应用程序中，应该使用Python的线程支持还是PyQt的线程支持？答案是，这取决于情况。</p>
<p>例如，如果您正在构建一个既有GUI应用程序，又有一个<a href="https://realpython.com/python-web-applications/">Web版</a>，那么Python的线程可能更合适，因为您的后端不会完全依赖PyQt。然而，如果您正在构建裸的PyQt应用程序，则PyQt的线程适合您。</p>
<p>使用PyQt的线程支持提供以下好处：</p>
<ul>
<li><strong>线程相关类</strong>与PyQt基础设施完全集成。</li>
<li><strong>工作线程</strong>可以有自己的事件循环，从而启用事件处理。</li>
<li>使用信号和槽可以进行<strong>线程间通信</strong>。</li>
</ul>
<p>一个经验法则可能是，如果您要与库的其余部分进行交互，则使用PyQt的线程支持，否则使用Python的线程支持。</p>
<h2 id="QThread实现流程"><a href="#QThread实现流程" class="headerlink" title="QThread实现流程"></a>QThread实现流程</h2><p>在GUI应用程序中，使用线程的常见用途是将长时间运行的任务分配给工作线程，以便GUI对用户的交互保持响应。在PyQt中，您可以使用<a href="https://doc.qt.io/qt-5/qthread.html"><code>QThread</code></a>来创建和管理工作线程。</p>
<p>根据Qt的文档，使用<code>QThread</code>创建工作线程有<a href="https://doc.qt.io/qt-5/qthread.html#details">两种主要方式</a>：</p>
<ol>
<li>直接实例化<code>QThread</code>，并创建一个工作的<code>QObject</code>，然后使用线程作为参数，调用<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtcore/qobject.html#moveToThread"><code>.moveToThread()</code></a>将工作对象移动到工作线程。工作对象必须包含执行特定任务所需的所有功能。</li>
<li>子类化<code>QThread</code>并重新实现<code>.run()</code>。<code>.run()</code>的实现必须包含执行特定任务所需的所有功能。</li>
</ol>
<p>例化<code>QThread</code>提供了一个并行事件循环。事件循环允许由线程拥有的对象在其槽上接收信号，并且这些槽将在线程内执行。</p>
<p>另一方面，子类化<code>QThread</code>允许在没有事件循环的情况下运行并行代码。使用这种方法，您始终可以通过显式调用<a href="https://doc.qt.io/qt-5/qthread.html#exec">exec()</a>来创建一个事件循环。</p>
<h2 id="QThread实现案例"><a href="#QThread实现案例" class="headerlink" title="QThread实现案例"></a>QThread实现案例</h2><p>考虑这样一段功能：实现两个按钮，按钮1🔘逐次打印1，2，3，4，5。按钮2🔘逐次打印a,b,c,d,e。</p>
<p>都在主线程里执行必然会卡死，各位读者应该也深有感触，不然也不会想看这篇文章了吧🥹这里就不再错误示范了，直接上多线程代码。注意多线程有两种实现方式，分别是继承QObject作为工作块，之后再创建线程，或者定义类继承QThread并覆写run方法，这里采用第二种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 继承QThread</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_1</span>(<span class="title class_ inherited__">QThread</span>):  <span class="comment"># 线程1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)  <span class="comment"># 休眠</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_2</span>(<span class="title class_ inherited__">QThread</span>):  <span class="comment"># 线程2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        values = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主界面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWin</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        layout = QVBoxLayout()</span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">        self.resize(<span class="number">500</span>, <span class="number">400</span>)</span><br><span class="line">        self.btn_1 = QPushButton(<span class="string">&quot;button 1&quot;</span>)</span><br><span class="line">        layout.addWidget(self.btn_1)</span><br><span class="line">        self.btn_1.clicked.connect(self.click_1)</span><br><span class="line">        self.btn_1.setObjectName(<span class="string">&quot;btn_1&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.btn_2 = QPushButton(<span class="string">&quot;button 2&quot;</span>)</span><br><span class="line">        self.btn_2.setObjectName(<span class="string">&quot;btn_2&quot;</span>)</span><br><span class="line">        self.btn_2.clicked.connect(self.click_2)</span><br><span class="line">        layout.addWidget(self.btn_2)</span><br><span class="line">        self.setLayout(layout)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_1</span>(<span class="params">self</span>):</span><br><span class="line">        self.thread1 = Thread_1()</span><br><span class="line">        self.thread1.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_2</span>(<span class="params">self</span>):</span><br><span class="line">        self.thread2 = Thread_2()</span><br><span class="line">        self.thread2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    myShow = MyWin()</span><br><span class="line">    myShow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

<p>注意这里覆写run方法之后只需要在主类中创建线程对象然后调用其start方法即可。这段程序的执行结果如何呢？不会出现卡死，而且可以两个按钮执行内容交替执行。</p>
<p><img src="/img/demo.png" alt="image-20230430193922703"></p>
<p>但是有一个严重的问题，就是当快速连续按下两次同一个按钮时，当第一次执行完毕后会将线程删除，从而导致这样的闪退：<code>QThread: Destroyed while thread is still running</code>。我们想实现的是在循环没有结束之前线程不允许使用，这时可以采用两种办法：线程锁🔒和信号。</p>
<p>先来说第一种方法，我们创建两个进程锁，然后在run方法里加锁和解锁，这样可以实现线程的互斥，就和操作系统里讲解的P&amp;V原语一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mutex1 = QMutex()</span><br><span class="line">mutex2 = QMutex()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_1</span>(<span class="title class_ inherited__">QThread</span>):  <span class="comment"># 线程1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        mutex1.lock()</span><br><span class="line">        values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)  <span class="comment"># 休眠</span></span><br><span class="line">        mutex1.unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_2</span>(<span class="title class_ inherited__">QThread</span>):  <span class="comment"># 线程2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        mutex2.lock()</span><br><span class="line">        values = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        mutex2.unlock()</span><br></pre></td></tr></table></figure>



<p>但这样的策略只是防止了闪退报错而已（emm我的mac在手速很快的情况还是会闪退，难绷），而且还没达到我们的目的。</p>
<p>所以我们引入信号，在按钮被按下时将按钮设置为不可用，在循环结束之后传递信号使按钮可用，这样就完美实现我们的功能啦～🌹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_1</span>(<span class="title class_ inherited__">QThread</span>):  <span class="comment"># 线程1</span></span><br><span class="line">    block_signal = pyqtSignal()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)  <span class="comment"># 休眠</span></span><br><span class="line">        self.block_signal.emit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_2</span>(<span class="title class_ inherited__">QThread</span>):  <span class="comment"># 线程2</span></span><br><span class="line">    block_signal = pyqtSignal()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        values = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.block_signal.emit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWin</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        layout = QVBoxLayout()</span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">        self.resize(<span class="number">500</span>, <span class="number">400</span>)</span><br><span class="line">        self.btn_1 = QPushButton(<span class="string">&quot;button 1&quot;</span>)</span><br><span class="line">        layout.addWidget(self.btn_1)</span><br><span class="line">        self.btn_1.clicked.connect(self.click_1)</span><br><span class="line">        self.btn_1.setObjectName(<span class="string">&quot;btn_1&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.btn_2 = QPushButton(<span class="string">&quot;button 2&quot;</span>)</span><br><span class="line">        self.btn_2.setObjectName(<span class="string">&quot;btn_2&quot;</span>)</span><br><span class="line">        self.btn_2.clicked.connect(self.click_2)</span><br><span class="line">        layout.addWidget(self.btn_2)</span><br><span class="line">        self.setLayout(layout)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_1</span>(<span class="params">self</span>):</span><br><span class="line">        self.btn_1.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        self.thread1 = Thread_1()</span><br><span class="line">        self.thread1.block_signal.connect(<span class="keyword">lambda</span>: self.btn_1.setEnabled(<span class="literal">True</span>))</span><br><span class="line">        self.thread1.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_2</span>(<span class="params">self</span>):</span><br><span class="line">        self.btn_2.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        self.thread2 = Thread_2()</span><br><span class="line">        self.thread2.block_signal.connect(<span class="keyword">lambda</span>: self.btn_2.setEnabled(<span class="literal">True</span>))</span><br><span class="line">        self.thread2.start()</span><br></pre></td></tr></table></figure>

<p>个人不习惯继承QThread类，虽然简单直接，但是功能没有另一种实现方式广泛（个人觉得），所以这里附上继承QObject的实现方式(yysy继承QObject真的有够累的😇)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_1</span>(<span class="title class_ inherited__">QObject</span>):  <span class="comment"># 线程1</span></span><br><span class="line">    block_signal = pyqtSignal()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)  <span class="comment"># 休眠</span></span><br><span class="line">        self.block_signal.emit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_2</span>(<span class="title class_ inherited__">QObject</span>):  <span class="comment"># 线程2</span></span><br><span class="line">    block_signal = pyqtSignal()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        values = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.block_signal.emit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWin</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        layout = QVBoxLayout()</span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">        self.resize(<span class="number">500</span>, <span class="number">400</span>)</span><br><span class="line">        self.btn_1 = QPushButton(<span class="string">&quot;button 1&quot;</span>)</span><br><span class="line">        layout.addWidget(self.btn_1)</span><br><span class="line">        self.btn_1.clicked.connect(self.click_1)</span><br><span class="line">        self.btn_1.setObjectName(<span class="string">&quot;btn_1&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.btn_2 = QPushButton(<span class="string">&quot;button 2&quot;</span>)</span><br><span class="line">        self.btn_2.setObjectName(<span class="string">&quot;btn_2&quot;</span>)</span><br><span class="line">        self.btn_2.clicked.connect(self.click_2)</span><br><span class="line">        layout.addWidget(self.btn_2)</span><br><span class="line">        self.setLayout(layout)</span><br><span class="line"></span><br><span class="line">        self.thread1 = QThread()</span><br><span class="line">        self.thread2 = QThread()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 把self.thread1的声明放这里也行</span></span><br><span class="line">        self.btn_1.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        self.worker1 = Thread_1()</span><br><span class="line">        self.worker1.moveToThread(self.thread1)</span><br><span class="line">        self.thread1.started.connect(self.worker1.run)</span><br><span class="line">        self.worker1.block_signal.connect(<span class="keyword">lambda</span>: self.btn_1.setEnabled(<span class="literal">True</span>))</span><br><span class="line">        self.worker1.block_signal.connect(self.thread1.quit)  <span class="comment"># 这句话非常重要，不然线程不知道啥时候结束，下一次信号就没法执行</span></span><br><span class="line">        self.thread1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 把self.thread2的声明放这里也行</span></span><br><span class="line">        self.btn_2.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        self.worker2 = Thread_2()</span><br><span class="line">        self.worker2.moveToThread(self.thread2)</span><br><span class="line">        self.thread2.started.connect(self.worker2.run)</span><br><span class="line">        self.worker2.block_signal.connect(<span class="keyword">lambda</span>: self.btn_2.setEnabled(<span class="literal">True</span>))</span><br><span class="line">        self.worker2.block_signal.connect(self.thread2.quit)  <span class="comment"># 这句话非常重要，不然线程不知道啥时候结束，下一次信号就没法执行</span></span><br><span class="line"></span><br><span class="line">        self.thread2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    myShow = MyWin()</span><br><span class="line">    myShow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>多线程，Pyqt5</tag>
      </tags>
  </entry>
  <entry>
    <title>分层架构</title>
    <url>/2023/05/17/%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html">www.oreilly.com</a></p>
</blockquote>
<blockquote>
<p>Chapter 1. Layered Architecture The most common architecture pattern is the layered architecture pat……</p>
</blockquote>
<h1 id="Chapter-1-Layered-Architecture"><a href="#Chapter-1-Layered-Architecture" class="headerlink" title="Chapter 1. Layered Architecture"></a>Chapter 1. Layered Architecture</h1><h1 id="第一章分层架构"><a href="#第一章分层架构" class="headerlink" title="第一章分层架构"></a>第一章分层架构</h1><p>The most common architecture pattern is the layered architecture pattern, otherwise known as the n-tier architecture pattern. This pattern is the de facto standard for most Java EE applications and therefore is widely known by most architects, designers, and developers. The layered architecture pattern closely matches the traditional IT communication and organizational structures found in most companies, making it a natural choice for most business application development efforts. </p>
<p>最常见的架构模式是分层架构模式，也称为 n 层架构模式。这种模式是大多数 JavaEE 应用程序的行业标准，因此为大多数架构师、设计师和开发人员所熟知。分层体系结构模式与大多数公司中的传统 IT 通信和组织结构非常匹配，这使其成为大多数业务应用程序开发工作的自然选择。 </p>
<h1 id="Pattern-Description"><a href="#Pattern-Description" class="headerlink" title="Pattern Description"></a>Pattern Description</h1><h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>Components within the layered architecture pattern are organized into horizontal layers, each layer performing a specific role within the application (e.g., presentation logic or business logic). Although the layered architecture pattern does not specify the number and types of layers that must exist in the pattern, most layered architectures consist of four standard layers: presentation, business, persistence, and database (<a href="#sapr_0101_img">Figure 1-1</a>). In some cases, the business layer and persistence layer are combined into a single business layer, particularly when the persistence logic (e.g., SQL or HSQL) is embedded within the business layer components. Thus, smaller applications may have only three layers, whereas larger and more complex business applications may contain five or more layers. </p>
<p>分层体系结构模式中的组件被组织成水平层，每个层在应用程序中执行特定的角色 (例如，表示逻辑或业务逻辑)。尽管分层架构模式没有指定模式中必须存在的层的数量和类型，但是大多数分层架构由四个标准层组成: 表示层、业务层、持久层和数据库层(图 1-1)。在某些情况下，业务层和持久层合并为一个业务层，特别是当持久化逻辑(例如 SQL 或 HSQL) 嵌入到业务层组件中时。因此，较小的应用程序可能只有三层，而较大和更复杂的业务应用程序可能包含五层或更多层。 </p>
<p>Each layer of the layered architecture pattern has a specific role and responsibility within the application. For example, a presentation layer would be responsible for handling all user interface and browser communication logic, whereas a business layer would be responsible for executing specific business rules associated with the request. Each layer in the architecture forms an abstraction around the work that needs to be done to satisfy a particular business request. For example, the presentation layer doesn’t need to know or worry about <em>how</em> to get customer data; it only needs to display that information on a screen in particular format. Similarly, the business layer doesn’t need to be concerned about how to format customer data for display on a screen or even where the customer data is coming from; it only needs to get the data from the persistence layer, perform business logic against the data (e.g., calculate values or aggregate data), and pass that information up to the presentation layer.  </p>
<p>分层架构模式的每一层在应用程序中都有特定的角色和职责。例如，表示层负责处理所有用户界面和浏览器通信逻辑，而业务层负责执行与请求相关的特定业务规则。体系结构中的每一层都围绕满足特定业务请求所需完成的工作形成一个抽象。例如，表示层不需要知道或担心如何获取客户数据; 它只需要在屏幕上以特定的格式显示该信息。类似地，业务层不需要关心如何格式化客户数据以便在屏幕上显示，甚至不需要关心客户数据来自哪里; 它只需要从持久层获取数据，对数据执行业务逻辑 (例如，计算值或聚合数据) ，并将该信息传递给表示层。  </p>
<p><img src="https://www.oreilly.com/api/v2/epubs/9781491971437/files/assets/sapr_0101.png"></p>
<h6 id="Figure-1-1-Layered-architecture-pattern"><a href="#Figure-1-1-Layered-architecture-pattern" class="headerlink" title="Figure 1-1. Layered architecture pattern"></a>Figure 1-1. Layered architecture pattern</h6><h6 id="图-1-1-分层架构模式"><a href="#图-1-1-分层架构模式" class="headerlink" title="图 1-1 分层架构模式"></a>图 1-1 分层架构模式</h6><p>One of the powerful features of the layered architecture pattern is the <em>separation of concerns</em> among components. Components within a specific layer deal only with logic that pertains to that layer. For example, components in the presentation layer deal only with presentation logic, whereas components residing in the business layer deal only with business logic. This type of component classification makes it easy to build effective roles and responsibility models into your architecture, and also makes it easy to develop, test, govern, and maintain applications using this architecture pattern due to well-defined component interfaces and limited component scope.</p>
<p>分层架构模式的一个强大特性是组件之间的关注点分离。特定层中的组件只处理属于该层的逻辑。例如，表示层中的组件只处理表示逻辑，而业务层中的组件只处理业务逻辑。这种类型的组件分类使得在体系结构中构建有效的角色和职责模型变得非常容易，而且由于定义良好的组件接口和有限的组件范围，使得使用这种体系结构模式开发、测试、治理和维护应用程序变得非常容易。</p>
<h1 id="Key-Concepts"><a href="#Key-Concepts" class="headerlink" title="Key Concepts"></a>Key Concepts</h1><h1 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h1><p>Notice in <a href="#sapr_0102_img">Figure 1-2</a> that each of the layers in the architecture is marked as being <em>closed</em>. This is a very important concept in the layered architecture pattern. A closed layer means that as a request moves from layer to layer, it must go through the layer right below it to get to the next layer below that one. For example, a request originating from the presentation layer must first go through the business layer and then to the persistence layer before finally hitting the database layer. </p>
<p>注意，在图 1-2 中，体系结构中的每个层都被标记为已关闭。这是分层架构模式中的一个非常重要的概念。封闭层意味着当一个请求从一个层移动到另一个层时，它必须通过它下面的层才能到达下一个层。例如，来自表示层的请求必须首先经过业务层，然后到达持久层，最后才能到达数据库层。 </p>
<p><img src="https://www.oreilly.com/api/v2/epubs/9781491971437/files/assets/sapr_0102.png"></p>
<h6 id="Figure-1-2-Closed-layers-and-request-access"><a href="#Figure-1-2-Closed-layers-and-request-access" class="headerlink" title="Figure 1-2. Closed layers and request access"></a>Figure 1-2. Closed layers and request access</h6><h6 id="图-1-2。封闭层和请求访问"><a href="#图-1-2。封闭层和请求访问" class="headerlink" title="图 1-2。封闭层和请求访问"></a>图 1-2。封闭层和请求访问</h6><p>So why not allow the presentation layer direct access to either the persistence layer or database layer? After all, direct database access from the presentation layer is much faster than going through a bunch of unnecessary layers just to retrieve or save database information. The answer to this question lies in a key concept known as <em>layers of isolation</em>. </p>
<p>那么，为什么不允许表示层直接访问持久层或数据库层呢？毕竟，从表示层直接访问数据库要比仅仅为了检索或保存数据库信息而穿过一大堆不必要的层快得多。这个问题的答案在于一个被称为隔离层的关键概念。 </p>
<p>The layers of isolation concept means that changes made in one layer of the architecture generally don’t impact or affect components in other layers: the change is isolated to the components within that layer, and possibly another associated layer (such as a persistence layer containing SQL). If you allow the presentation layer direct access to the persistence layer, then changes made to SQL within the persistence layer would impact both the business layer and the presentation layer, thereby producing a very tightly coupled application with lots of interdependencies between components. This type of architecture then becomes very hard and expensive to change.  </p>
<p>隔离层的概念意味着在体系结构的一个层中所做的更改通常不会影响或影响其他层中的组件: 这个更改被隔离到该层中的组件，可能还有另一个相关联的层 (比如包含 SQL 的持久层)。如果允许表示层直接访问持久层，那么对持久层中的 SQL 所做的更改将同时影响业务层和表示层，从而产生一个具有组件之间大量相互依赖性的非常紧密耦合的应用程序。这种类型的体系结构变得非常困难和昂贵的改变。  </p>
<p>The layers of isolation concept also means that each layer is independent of the other layers, thereby having little or no knowledge of the inner workings of other layers in the architecture. To understand the power and importance of this concept, consider a large refactoring effort to convert the presentation framework from JSP (Java Server Pages) to JSF (Java Server Faces). Assuming that the contracts (e.g., model) used between the presentation layer and the business layer remain the same, the business layer is not affected by the refactoring and remains completely independent of the type of user-interface framework used by the presentation layer.  </p>
<p>隔离层的概念还意味着每一层独立于其他层，因此对体系结构中其他层的内部工作原理知之甚少或根本不知道。为了理解这个概念的力量和重要性，请考虑进行大规模的重构工作，将表示框架从 JSP (Java Server Pages)转换为 JSF (Java Server Faces)。假设表示层和业务层之间使用的契约 (例如，模型) 保持不变，业务层不受重构的影响，并且完全独立于表示层使用的用户界面框架的类型。  </p>
<p>While closed layers facilitate layers of isolation and therefore help isolate change within the architecture, there are times when it makes sense for certain layers to be open. For example, suppose you want to add a shared-services layer to an architecture containing common service components accessed by components within the business layer (e.g., data and string utility classes or auditing and logging classes). Creating a services layer is usually a good idea in this case because architecturally it restricts access to the shared services to the business layer (and not the presentation layer). Without a separate layer, there is nothing architecturally that restricts the presentation layer from accessing these common services, making it difficult to govern this access restriction.  </p>
<p>虽然封闭层有助于隔离层，因此有助于隔离体系结构中的更改，但有时候某些层开放是有意义的。例如，假设您希望将共享服务层添加到一个体系结构中，该体系结构包含由业务层中的组件访问的公共服务组件 (例如，数据和字符串实用工具类或审计和日志记录类)。在这种情况下，创建服务层通常是一个好主意，因为在体系结构上，它将对共享服务的访问限制在业务层 (而不是表示层)。如果没有单独的层，那么在体系结构上就不存在任何限制表示层访问这些公共服务的东西，这使得很难控制这种访问限制。  </p>
<p>In this example, the new services layer would likely reside <em>below</em> the business layer to indicate that components in this services layer are not accessible from the presentation layer. However, this presents a problem in that the business layer is now required to go through the services layer to get to the persistence layer, which makes no sense at all. This is an age-old problem with the layered architecture, and is solved by creating open layers within the architecture.  </p>
<p>在这个示例中，新的服务层可能位于业务层之下，以指示此服务层中的组件不能从表示层访问。但是，这样就出现了一个问题，业务层现在需要穿过服务层才能到达持久层，这是毫无意义的。这是分层体系结构的一个古老问题，可以通过在体系结构中创建开放层来解决。  </p>
<p>As illustrated in <a href="#sapr_0103_img">Figure 1-3</a>, the services layer in this case is marked as open,  meaning requests are allowed to bypass this open layer and go directly to the layer below it. In the following example, since the services layer is open, the business layer is now allowed to bypass it and go directly to the persistence layer, which makes perfect sense.  </p>
<p>如图 1-3 所示，在这种情况下，服务层被标记为打开的，这意味着请求可以绕过这个打开的层，直接进入它下面的层。在下面的示例中，因为服务层是开放的，所以现在允许业务层绕过它，直接进入持久层，这非常有意义。  </p>
<p><img src="https://www.oreilly.com/api/v2/epubs/9781491971437/files/assets/sapr_0103.png"></p>
<h6 id="Figure-1-3-Open-layers-and-request-flow"><a href="#Figure-1-3-Open-layers-and-request-flow" class="headerlink" title="Figure 1-3. Open layers and request flow"></a>Figure 1-3. Open layers and request flow</h6><h6 id="图-1-3。打开层和请求流"><a href="#图-1-3。打开层和请求流" class="headerlink" title="图 1-3。打开层和请求流"></a>图 1-3。打开层和请求流</h6><p>Leveraging the concept of open and closed layers helps define the relationship between architecture layers and request flows and also provides designers and developers with the necessary information to understand the various layer access restrictions within the architecture. Failure to document or properly communicate which layers in the architecture are open and closed (and why) usually results in tightly coupled and brittle architectures that are very difficult to test, maintain, and deploy.</p>
<p>利用开放和封闭层的概念有助于定义体系结构层和请求流之间的关系，并为设计人员和开发人员提供必要的信息，以理解体系结构中各种层访问限制。如果不能记录或正确地交流架构中的哪些层是开放和关闭的 (以及为什么) ，通常会导致紧密耦合和脆弱的架构，这些架构很难测试、维护和部署。</p>
<h1 id="Pattern-Example"><a href="#Pattern-Example" class="headerlink" title="Pattern Example"></a>Pattern Example</h1><h1 id="模式示例"><a href="#模式示例" class="headerlink" title="模式示例"></a>模式示例</h1><p>To illustrate how the layered architecture works, consider a request from a business user to retrieve customer information for a particular individual as illustrated in <a href="#sapr_0104_img">Figure 1-4</a>. The black arrows show the request flowing down to the database to retrieve the customer data, and the red arrows show the response flowing back up to the screen to display the data. In this example, the customer information consists of both customer data and order data (orders placed by the customer).  </p>
<p>为了说明分层架构是如何工作的，考虑一个来自业务用户的请求，为一个特定的个人检索客户信息，如图 1-4 所示。黑色箭头显示流向数据库以检索客户数据的请求，红色箭头显示流回屏幕以显示数据的响应。在此示例中，客户信息由客户数据和订单数据 (由客户下达的订单) 组成。  </p>
<p>The <em>customer screen</em> is responsible for accepting the request and displaying the customer information. It does not know where the data is, how it is retrieved, or how many database tables must be queries to get the data. Once the customer screen receives a request to get customer information for a particular individual, it then forwards that request onto the <em>customer delegate</em> module. This module is responsible for knowing which modules in the business layer can process that request and also how to get to that module and what data it needs (the contract). The <em>customer object</em> in the business layer is responsible for aggregating all of the information needed by the business request (in this case to get customer information). This module calls out to the <em>customer dao</em> (data access object) module in the persistence layer to get customer data, and also the <em>order dao</em> module to get order information. These modules in turn execute SQL statements to retrieve the corresponding data and pass it back up to the customer object in the business layer. Once the customer object receives the data, it aggregates the data and passes that information back up to the customer delegate, which then passes that data to the customer screen to be presented to the user.      </p>
<p>客户屏幕负责接受请求并显示客户信息。它不知道数据在哪里，如何检索数据，或者必须查询多少个数据库表才能获得数据。一旦客户屏幕接收到为特定个人获取客户信息的请求，它就会将该请求转发到客户委托模块。该模块负责了解业务层中哪些模块可以处理该请求，以及如何访问该模块和它需要什么数据 (契约)。业务层中的客户对象负责聚合业务请求所需的所有信息(在本例中是为了获取客户信息)。该模块调用持久层中的客户道(数据访问对象) 模块来获取客户数据，同时调用订单道模块来获取订单信息。这些模块依次执行 SQL 语句来检索相应的数据，并将其传递回业务层中的客户对象。一旦客户对象接收到数据，它就会聚合数据并将该信息传递回客户委托，然后委托将该数据传递到客户屏幕，以呈现给用户。      </p>
<p><img src="https://www.oreilly.com/api/v2/epubs/9781491971437/files/assets/sapr_0104.png"></p>
<h6 id="Figure-1-4-Layered-architecture-example"><a href="#Figure-1-4-Layered-architecture-example" class="headerlink" title="Figure 1-4. Layered architecture example"></a>Figure 1-4. Layered architecture example</h6><h6 id="图-1-4。分层架构示例"><a href="#图-1-4。分层架构示例" class="headerlink" title="图 1-4。分层架构示例"></a>图 1-4。分层架构示例</h6><p>From a technology perspective, there are literally dozens of ways these modules can be implemented. For example, in the Java platform, the customer screen can be a (JSF) Java Server Faces screen coupled with the customer delegate as the managed bean component. The customer object in the business layer can be a local Spring bean or a remote EJB3 bean. The data access objects illustrated in the previous example can be implemented as simple POJO’s (Plain Old Java Objects), MyBatis XML Mapper files, or even objects encapsulating raw JDBC calls or Hibernate queries. From a Microsoft platform perspective, the customer screen can be an ASP (active server pages) module using the .NET framework to access C# modules in the business layer, with the customer and order data access modules implemented as ADO (ActiveX Data Objects). </p>
<p>从技术的角度来看，实现这些模块的方法有几十种。例如，在 Java 平台中，客户屏幕可以是 (JSF) JavaServerFaces 屏幕，客户委托作为托管 bean 组件耦合在一起。业务层中的客户对象可以是本地 Spring bean 或远程 EJB3 bean。前面示例中说明的数据访问对象可以实现为简单的 POJO (普通的旧 Java 对象)、 MyBatis XML Mapper 文件，甚至是封装原始 JDBC 调用或 Hibernate 查询的对象。从 Microsoft 平台的角度来看，客户界面可以是一个 ASP (活动服务器页) 模块，使用。NET 框架访问业务层的 C # 模块，客户和订单数据访问模块实现为 ADO (ADO)。 </p>
<h1 id="Considerations"><a href="#Considerations" class="headerlink" title="Considerations"></a>Considerations</h1><h1 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h1><p>The layered architecture pattern is a solid general-purpose pattern, making it a good starting point for most applications, particularly when you are not sure what architecture pattern is best suited for your application. However, there are a couple of things to consider from an architecture standpoint when choosing this pattern.</p>
<p>分层架构模式是一个坚实的通用模式，对于大多数应用程序来说，它是一个很好的起点，特别是当您不确定什么架构模式最适合您的应用程序时。然而，在选择这种模式时，从体系结构的角度来看，有一些事情需要考虑。</p>
<p>The first thing to watch out for is what is known as the <em>architecture sinkhole anti-pattern</em>. This anti-pattern describes the situation where requests flow through multiple layers of the architecture as simple pass-through processing with little or no logic performed within each layer. For example, assume the presentation layer responds to a request from the user to retrieve customer data. The presentation layer passes the request to the business layer, which simply passes the request to the persistence layer, which then makes a simple SQL call to the database layer to retrieve the customer data. The data is then passed all the way back up the stack with no additional processing or logic to aggregate, calculate, or transform the data. </p>
<p>首先要注意的是所谓的建筑陷坑反模式。这个反模式描述了这样一种情况，即请求流通过体系结构的多个层，作为简单的传递处理，在每个层中很少或根本不执行逻辑。例如，假设表示层响应来自用户的检索客户数据的请求。表示层将请求传递给业务层，业务层只是将请求传递给持久层，然后持久层对数据库层执行一个简单的 SQL 调用以检索客户数据。然后将数据一路传递回堆栈，不需要额外的处理或逻辑来聚合、计算或转换数据。 </p>
<p>Every layered architecture will have at least some scenarios that fall into the architecture sinkhole anti-pattern. The key, however, is to analyze the percentage of requests that fall into this category. The 80-20 rule is usually a good practice to follow to determine whether or not you are experiencing the architecture sinkhole anti-pattern. It is typical to have around 20 percent of the requests as simple pass-through processing and 80 percent of the requests having some business logic associated with the request. However, if you find that this ratio is reversed and a majority of your requests are simple pass-through processing, you might want to consider making some of the architecture layers open, keeping in mind that it will be more difficult to control change due to the lack of layer isolation. </p>
<p>每个分层体系结构都至少有一些场景落入体系结构陷坑反模式。但是，关键是要分析属于这一类别的请求的百分比。80-20 规则通常是一个很好的实践，可以用来确定您是否正在经历体系结构陷坑反模式。通常有大约 20% 的请求作为简单的传递处理，80% 的请求具有与请求相关联的一些业务逻辑。但是，如果您发现这个比例是相反的，并且您的大多数请求都是简单的传递处理，那么您可能需要考虑开放一些架构层，请记住，由于缺乏层隔离，控制更改将更加困难。 </p>
<p>Another consideration with the layered architecture pattern is that it tends to lend itself toward monolithic applications, even if you split the presentation layer and business layers into separate deployable units. While this may not be a concern for some applications, it does pose some potential issues in terms of deployment, general robustness and reliability, performance, and scalability.   </p>
<p>分层体系结构模式的另一个考虑因素是，即使您将表示层和业务层划分为单独的可部署单元，它也倾向于使用单一应用程序。虽然这可能不是某些应用程序所关心的问题，但是它确实在部署、一般的健壮性和可靠性、性能和可伸缩性方面提出了一些潜在的问题。   </p>
<h1 id="Pattern-Analysis"><a href="#Pattern-Analysis" class="headerlink" title="Pattern Analysis"></a>Pattern Analysis</h1><h1 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h1><p>The following table contains a rating and analysis of the common architecture characteristics for the layered architecture pattern. The rating for each characteristic is based on the natural tendency for that characteristic as a capability based on a typical implementation of the pattern, as well as what the pattern is generally known for. For a side-by-side comparison of how this pattern relates to other patterns in this report, please refer to <a href="app01.html#pattern-analysis-summary">Appendix A</a> at the end of this report.</p>
<p>下表对分层架构模式的常见架构特征进行了评级和分析。每个特征的评级基于该特征的自然趋势，即基于模式的典型实现的功能，以及模式通常为人所知的功能。关于这种模式与本报告中其他模式的并行比较，请参阅本报告末尾的附录 A。</p>
<p><strong>Overall agility</strong></p>
<p>整体灵活性</p>
<p><em>Rating:</em> Low</p>
<p>评分: 低</p>
<p><em>Analysis:</em> Overall agility is the ability to respond quickly to a constantly changing environment. While change can be isolated through the layers of isolation feature of this pattern, it is still cumbersome and time-consuming to make changes in this architecture pattern because of the monolithic nature of most implementations as well as the tight coupling of components usually found with this pattern.</p>
<p>分析: 总体敏捷性是对不断变化的环境作出快速反应的能力。虽然可以通过这个模式的隔离特性层来隔离变更，但是在这个架构模式中进行变更仍然是非常麻烦和耗时的，因为大多数实现的单一性以及通常与这个模式相关的组件之间的紧密耦合。</p>
<p><strong>Ease of deployment</strong></p>
<p>易于部署</p>
<p><em>Rating:</em> Low</p>
<p>评分: 低</p>
<p><em>Analysis:</em> Depending on how you implement this pattern, deployment can become an issue, particularly for larger applications. One small change to a component can require a redeployment of the entire application (or a large portion of the application), resulting in deployments that need to be planned, scheduled, and executed during off-hours or on weekends. As such, this pattern does not easily lend itself toward a continuous delivery pipeline, further reducing the overall rating for deployment.</p>
<p>分析: 根据您实现此模式的方式，部署可能成为一个问题，特别是对于较大的应用程序。对组件的一个小更改可能需要重新部署整个应用程序 (或应用程序的大部分) ，导致需要在非工作时间或周末计划、安排和执行部署。因此，这种模式不容易适用于持续交付管道，从而进一步降低了部署的总体评级。</p>
<p><strong>Testability</strong></p>
<p>可测试性</p>
<p><em>Rating:</em> High</p>
<p>收视率: 高</p>
<p><em>Analysis:</em> Because components belong to specific layers in the architecture, other layers can be mocked or stubbed, making this pattern is relatively easy to test. A developer can mock a presentation component or screen to isolate testing within a business component, as well as mock the business layer to test certain screen functionality.</p>
<p>分析: 因为组件属于体系结构中的特定层，所以其他层可以被模拟或存根化，这使得该模式相对容易测试。开发人员可以模拟表示组件或屏幕来隔离业务组件中的测试，也可以模拟业务层来测试某些屏幕功能。</p>
<p><strong>Performance</strong></p>
<p>表演</p>
<p><em>Rating:</em> Low</p>
<p>评分: 低</p>
<p><em>Analysis:</em> While it is true some layered architectures can perform well, the pattern does not lend itself to high-performance applications due to the inefficiencies of having to go through multiple layers of the architecture to fulfill a business request.</p>
<p>分析: 虽然一些分层架构确实可以很好地执行，但是由于必须通过多层架构来满足业务请求的效率低下，这种模式不适合高性能应用程序。</p>
<p><strong>Scalability</strong></p>
<p>可伸缩性</p>
<p><em>Rating:</em> Low</p>
<p>评分: 低</p>
<p><em>Analysis:</em> Because of the trend toward tightly coupled and monolithic implementations of this pattern, applications build using this architecture pattern are generally difficult to scale. You can scale a layered architecture by splitting the layers into separate physical deployments or replicating the entire application into multiple nodes, but overall the granularity is too broad, making it expensive to scale.</p>
<p>分析: 由于这种模式的紧密耦合和单片实现的趋势，使用这种体系结构模式构建的应用程序通常难以扩展。您可以通过将层划分为单独的物理部署或将整个应用程序复制到多个节点来扩展分层体系结构，但总体而言粒度太大，因此扩展成本很高。</p>
<p><strong>Ease of development</strong></p>
<p>易于开发</p>
<p><em>Rating:</em> High</p>
<p>收视率: 高</p>
<p><em>Analysis:</em> Ease of development gets a relatively high score, mostly because this pattern is so well known and is not overly complex to implement. Because most companies develop applications by separating skill sets by layers (presentation, business, database), this pattern becomes a natural choice for most business-application development. The connection between a company’s communication and organization structure and the way it develops software is outlined is what is called <em>Conway’s law</em>. You can Google “Conway’s law” to get more information about this fascinating correlation.</p>
<p>分析: 易于开发得到了相对较高的分数，主要是因为这种模式是众所周知的，并且实现起来不会过于复杂。因为大多数公司通过按层 (表示、业务、数据库) 分离技能集来开发应用程序，所以这种模式成为大多数业务应用程序开发的自然选择。一个公司的沟通和组织结构与它开发软件的方式之间的联系被概述为所谓的康威定律。你可以在谷歌上搜索 “康威定律” 来获得更多关于这种迷人的相关性的信息。</p>
]]></content>
      <tags>
        <tag>系统分析与设计，分层架构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库范式详解</title>
    <url>/2023/05/14/%E4%B8%80%E5%88%B0%E4%BA%94%E8%8C%83%E5%BC%8F%E3%80%81BC%20%E8%8C%83%E5%BC%8F%E4%B8%8E%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://zhuanlan.zhihu.com/p/568559424">zhuanlan.zhihu.com</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>MySQL 的库表设计，在很多时候我们都是率性而为，往往在前期的设计中考虑并不全面，同时对于库表结构的划分也并不明确，所以很多时候在开发过程中，代码敲着敲着会去重构某张表结构，甚至大面积重构多张表结构，这种随心所欲的设计方式，无疑给开发造成了很大困扰。</p>
<p>但实际上设计 DB 库表结构时，也有一些共同需要遵守的规范，这些规范在数据库设计中被称为 “范式”，理解并掌握这些设计时的规范，能让咱们在项目之初，设计的库表结构更为合理且优雅。数据库范式中，声名远扬的有三大范式，但除此之外也有一些其他设计规范，如：</p>
<ul>
<li>①数据库三大范式（1NF、2NF、3NF）</li>
<li>③第四范式 (4NF）和第五范式：完美范式（5NF）</li>
<li>②巴斯 - 科德范式（BCNF）</li>
<li>④反范式设计</li>
</ul>
<p>不过对于上述的几种设计范式，大部分小伙伴应该仅了解过三范式，对于其他的应该未曾接触，那在本篇中会重点阐述库表设计时，会用到的这些范式。</p>
<h2 id="一、数据库三大范式"><a href="#一、数据库三大范式" class="headerlink" title="一、数据库三大范式"></a>一、数据库三大范式</h2><p>范式 (Normal Form) 在前面也提到过，它就是指设计数据库时要遵守的一些原则，而数据库的三大范式，相信诸位在学习数据库知识时也定然接触过。三大范式之间，它们是递进的关系，也就是后续的范式都基于前一个范式的基础上推行，就好比下面这句话：</p>
<blockquote>
<p>今天我要先炒菜，然后吃饭，最后洗碗。</p>
</blockquote>
<p>炒菜、吃饭、洗碗三者也属于递进关系，后者都建立在前者之上，其顺序不能颠倒，比如先吃饭再炒菜，这必然是行不通的。数据库的三大范式也一样，第二范式必须建立在第一范式的基础之上，如若设计的库表第一范式都不满足，那定然是无法满足第二范式的。</p>
<blockquote>
<p>写在前面的话：其实对于数据库三范式相关的资料，网上也有很多很多，但大部分资料都涉及了太多的概念，通篇看下来也很难让人理解，因此下述的三范式则会结合具体的设计实例来让诸位彻底理解三范式。</p>
</blockquote>
<h2 id="1-1、第一范式（1NF）"><a href="#1-1、第一范式（1NF）" class="headerlink" title="1.1、第一范式（1NF）"></a>1.1、第一范式（1NF）</h2><p>库表设计时的第一范式，主要是为了确保原子性的，也就是存储的数据具备不可再分性，这话咋理解呢？上个案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `zz_student`;</span><br><span class="line">+----------------------+--------+-------+</span><br><span class="line">| student              | course | score |</span><br><span class="line">+----------------------+--------+-------+</span><br><span class="line">| 竹子，男，185cm      | 语文   |    95 |</span><br><span class="line">| 竹子，男，185cm      | 数学   |   100 |</span><br><span class="line">| 竹子，男，185cm      | 英语   |    88 |</span><br><span class="line">| 熊猫，女，170cm      | 语文   |    99 |</span><br><span class="line">| 熊猫，女，170cm      | 数学   |    90 |</span><br><span class="line">| 熊猫，女，170cm      | 英语   |    95 |</span><br><span class="line">+----------------------+--------+-------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上述的学生表中，其中有一个 student 学生列，这一列存储的数据则明显不符合第一范式：原子性的规定，因为这一列的数据还可以再拆分为姓名、性别、身高三项数据，因此为了符合第一范式，应该将表结构更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+----------------+--------+-------+</span><br><span class="line">| student_name | student_sex | student_height | course | score |</span><br><span class="line">+--------------+-------------+----------------+--------+-------+</span><br><span class="line">| 竹子         | 男          | 185cm          | 语文   |    95 |</span><br><span class="line">| 竹子         | 男          | 185cm          | 数学   |   100 |</span><br><span class="line">| 竹子         | 男          | 185cm          | 英语   |    88 |</span><br><span class="line">| 熊猫         | 女          | 170cm          | 语文   |    99 |</span><br><span class="line">| 熊猫         | 女          | 170cm          | 数学   |    90 |</span><br><span class="line">| 熊猫         | 女          | 170cm          | 英语   |    95 |</span><br><span class="line">+--------------+-------------+----------------+--------+-------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>将 student 这一列数据，分别拆分为姓名、性别、身高三列，然后分别存储对应的数据才合理，通过这样的优化后，此时 zz_student 这张表则符合了数据库设计的第一范式。</p>
<blockquote>
<p>那此刻思考一下：如果不去拆分列满足第一范式，会造成什么影响呢？</p>
</blockquote>
<ul>
<li>客户端语言和表之间无法很好的生成映射关系。</li>
<li>查询到数据后，需要处理数据时，还需要对 student 字段进行额外拆分。</li>
<li>插入数据时，对于第一个字段的值还需要先拼装后才能进行写入。</li>
</ul>
<p>简单来说，如果按照原本那张形式去做业务开发，显然操作起来会更加麻烦且复杂一些，但第一范式的原子性，除开对列级别生效之外，行级别的数据也是同理，也就是每一行数据之间是互不影响的，都是独立的一个整体。</p>
<h2 id="1-2、第二范式（2NF）"><a href="#1-2、第二范式（2NF）" class="headerlink" title="1.2、第二范式（2NF）"></a>1.2、第二范式（2NF）</h2><p>上述的第一范式还是比较容易理解，紧接着来看看第二范式，第二范式的要求表中的所有列，其数据都必须依赖于主键，也就是一张表只存储同一类型的数据，不能有任何一列数据与主键没有关系，还是上面的那张表数据为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+----------------+--------+-------+</span><br><span class="line">| student_name | student_sex | student_height | course | score |</span><br><span class="line">+--------------+-------------+----------------+--------+-------+</span><br><span class="line">| 竹子         | 男          | 185cm          | 语文   |    95 |</span><br><span class="line">| 竹子         | 男          | 185cm          | 数学   |   100 |</span><br><span class="line">| 竹子         | 男          | 185cm          | 英语   |    88 |</span><br><span class="line">| 熊猫         | 女          | 170cm          | 语文   |    99 |</span><br><span class="line">| 熊猫         | 女          | 170cm          | 数学   |    90 |</span><br><span class="line">| 熊猫         | 女          | 170cm          | 英语   |    95 |</span><br><span class="line">+--------------+-------------+----------------+--------+-------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>虽然此时已经满足了数据库的第一范式，但此刻观察 course 课程、score 分数这两列数据，跟前面的几列数据实际上依赖关系并不大，同时也由于这样的结构，导致前面几列的数据出现了大量冗余，所以此时可以再次拆分一下表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `zz_student`;</span><br><span class="line">+------------+--------+------+--------+--------------+--------------+</span><br><span class="line">| student_id | name   | sex  | height | department   | dean         |</span><br><span class="line">+------------+--------+------+--------+--------------+--------------+</span><br><span class="line">|          1 | 竹子   | 男   | 185cm  | 计算机系     | 竹子老大     |</span><br><span class="line">|          2 | 熊猫   | 女   | 170cm  | 金融系       | 熊猫老大     |</span><br><span class="line">+------------+--------+------+--------+--------------+--------------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_course`;</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| course_id | course_name |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">|         1 | 语文        |</span><br><span class="line">|         2 | 数学        |</span><br><span class="line">|         3 | 英语        |</span><br><span class="line">+-----------+-------------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_score`;</span><br><span class="line">+----------+------------+-----------+-------+</span><br><span class="line">| score_id | student_id | course_id | score |</span><br><span class="line">+----------+------------+-----------+-------+</span><br><span class="line">|        1 |          1 |         1 |    95 |</span><br><span class="line">|        2 |          1 |         2 |   100 |</span><br><span class="line">|        3 |          1 |         3 |    88 |</span><br><span class="line">|        4 |          2 |         1 |    99 |</span><br><span class="line">|        5 |          2 |         2 |    90 |</span><br><span class="line">|        6 |          2 |         3 |    95 |</span><br><span class="line">+----------+------------+-----------+-------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>经过上述结构优化后，之前的一张表此时被我们拆分成学生表、课程表、成绩表三张，每张表中的 id 字段作为主键，其他字段都依赖这个主键。无论在哪张表中，都可以通过 id 主键确定其他字段的信息。</p>
<blockquote>
<p>主键可以不用 id，但最好是自增的主键 ID，这跟索引有关</p>
</blockquote>
<p>此时再将目光看到先后两张学生表，原本的学生表有六条学生记录，其中有四条是冗余数据，此时的学生表则只有两条数据，同时这张学生表中只存储学生信息相关的数据。经过本次结构优化后，每张表的业务属性都具备 “唯一性”，也就是每张表都只会描述了 “一件事情”，不会存在一张表中会出现两个业务属性（例如之前的学生表包含了学生信息和课程成绩）。</p>
<h2 id="1-3、第三范式（3NF）"><a href="#1-3、第三范式（3NF）" class="headerlink" title="1.3、第三范式（3NF）"></a>1.3、第三范式（3NF）</h2><p>前面已经对第一范式、第二范式进行了直观阐述，接下来聊一聊数据库的第三范式，第三范式要求表中每一列数据不能与主键之外的字段有直接关系，怎么理解呢？基于上述的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------+--------+------+--------+--------------+--------------+</span><br><span class="line">| student_id | name   | sex  | height | department   | dean         |</span><br><span class="line">+------------+--------+------+--------+--------------+--------------+</span><br><span class="line">|          1 | 竹子   | 男   | 185cm  | 计算机系     | 竹子老大     |</span><br><span class="line">|          2 | 熊猫   | 女   | 170cm  | 金融系       | 熊猫老大     |</span><br><span class="line">+------------+--------+------+--------+--------------+--------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>比如这张学生表，目前即符合第一范式，也符合第二范式，但看最后的两个字段，department 表示当前学生所属的院校，dean 则表示这个院系的院长是谁。一般来说，一个学生的院长是谁，首先是取决于学生所在的院系的，因此最后的 dean 字段明显与 department 字段存在依赖关系，因此需要进一步调整表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `department`;</span><br><span class="line">+---------------+-----------------+-----------------+</span><br><span class="line">| department_id | department_name | department_dean |</span><br><span class="line">+---------------+-----------------+-----------------+</span><br><span class="line">|             1 | 计算机系        | 竹子老大        |</span><br><span class="line">|             2 | 金融系          | 熊猫老大        |</span><br><span class="line">+---------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_student`;</span><br><span class="line">+------------+--------+------+--------+---------------+</span><br><span class="line">| student_id | name   | sex  | height | department_id |</span><br><span class="line">+------------+--------+------+--------+---------------+</span><br><span class="line">|          1 | 竹子   | 男   | 185cm  |             1 |</span><br><span class="line">|          2 | 熊猫   | 女   | 170cm  |             2 |</span><br><span class="line">+------------+--------+------+--------+---------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>经过进一步的结构优化后，又将原本的学生表拆为了院系表、学生表两张，学生表中则是只存储一个院系 ID，由院系表存储院系相关的所有数据。至此，学生表中的每个非主键字段与其他非主键字段之间，都是相互独立的，之间不会再存在任何依赖性，所有的字段都依赖于主键。</p>
<p>那这里为什么要调整呢？不调整不行吗？还真不行，来简单思考一下不调整结构的情况下会发生什么问题：</p>
<ul>
<li>①当一个院系的院长换人后，需要同时修改学生表中的多条数据。</li>
<li>②当一个院长离职后，需要删除该院长的记录，会同时删除多条学生信息。</li>
<li>……</li>
</ul>
<p>也就是如果设计的表结构，无法满足第三范式，在操作表时就会出现异常，使得整个表较难维护。</p>
<h2 id="1-4、数据库三范式小结"><a href="#1-4、数据库三范式小结" class="headerlink" title="1.4、数据库三范式小结"></a>1.4、数据库三范式小结</h2><p>到这里就已经将库表设计的三范式做了直观阐述，总结如下：</p>
<ul>
<li>第一范式：确保原子性，表中每一个列数据都必须是不可再分的字段。</li>
<li>第二范式：确保唯一性，每张表都只描述一种业务属性，一张表只描述一件事。</li>
<li>第三范式：确保独立性，表中除主键外，每个字段之间不存在任何依赖，都是独立的。</li>
</ul>
<p>经过三范式的示例后，数据库中的表数量也逐渐多了起来，似乎设计符合三范式的库表结构，反而更加麻烦了对吗？答案并非如此，因为在没有按照范式设计时，会存在几个问题：</p>
<ul>
<li>①整张表数据比较冗余，同一个学生信息会出现多条。</li>
<li>②表结构特别臃肿，不易于操作，要新增一个学生信息时，需添加大量数据。</li>
<li>③需要更新其他业务属性的数据时，比如院系院长换人了，需要修改所有学生的记录。</li>
</ul>
<p>但按照三范式将表结构拆开后，假设要新增一条学生数据，就只需要插入学生相关的信息即可，同时如果某个院系的院长换人了，只需要修改院系表中的院长就行，学生表中的数据无需发生任何更改。</p>
<blockquote>
<p>因此，经过三范式的设计优化后，整个库中的所有表结构，会显得更为优雅，灵活性也会更强。</p>
</blockquote>
<h2 id="二、巴斯-科德范式与第四、五范式"><a href="#二、巴斯-科德范式与第四、五范式" class="headerlink" title="二、巴斯 - 科德范式与第四、五范式"></a>二、巴斯 - 科德范式与第四、五范式</h2><p>第一阶段中，简单了解了库表设计时最基本的三大范式，但除此之外还有另外三种设计范式，即巴斯 - 科德范式与第四、第五范式，这后续三种范式可能有很多小伙伴没接触过，但当你尝试从网上去了解时，相信绝大部分能看到的资料你都看不懂，例如：</p>
<p><img src="https://pic2.zhimg.com/v2-496b967f6c3aa611b64bc79f989779a9_r.jpg"></p>
<p>观察上图中的描述，这一眼望过去几乎不是给人看的（没有诋毁的意思，单纯感慨~），其中涉及的码、完全函数依赖等名词，至少刚接触的小白是读不懂的，因此接下来则依旧采用上面那种案例 + 大白话的模式，简单阐述一下这三种设计范式。</p>
<h2 id="2-1、巴斯-科德范式（BCNF）"><a href="#2-1、巴斯-科德范式（BCNF）" class="headerlink" title="2.1、巴斯 - 科德范式（BCNF）"></a>2.1、巴斯 - 科德范式（BCNF）</h2><p>在了解后续这些范式之前，首先得弄明白一个概念，一般在一张表中，可以用于区分每行数据的一个列，通常会被咱们设为主键，例如常用的 ID 字段就是如此，这类主键通常被称为单一主键，即一个列组成的主键。但除此之外，还有一个联合主键的概念，也就是由多个列组成的主键，相信这点大家在学习数据库的时候也接触过。</p>
<p>巴斯 - 科德范式也被称为 3.5NF，至于为何不称为第四范式，这主要是由于它是第三范式的补充版，第三范式的要求是：任何非主键字段不能与其他非主键字段间存在依赖关系，也就是要求每个非主键字段之间要具备独立性。而巴斯 - 科德范式在第三范式的基础上，进一步要求：<strong>任何主属性不能对其他主键子集存在依赖</strong>。</p>
<blockquote>
<p>对于上述的范式定义大家估计有些晕，那用大白话说简单一点，也就是规定了联合主键中的某列值，不能与联合主键中的其他列存在依赖关系，相信这样讲大家更加容易理解。当然，还是结合一个案例阐述。</p>
</blockquote>
<p>先来看一张表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------+---------------+--------+------+--------+</span><br><span class="line">| classes           | class_adviser | name   | sex  | height |</span><br><span class="line">+-------------------+---------------+--------+------+--------+</span><br><span class="line">| 计算机-2201班     | 熊竹老师      | 竹子   | 男   | 185cm  |</span><br><span class="line">| 金融-2201班       | 竹熊老师      | 熊猫   | 女   | 170cm  |</span><br><span class="line">| 计算机-2201班     | 熊竹老师      | 子竹   | 男   | 180cm  |</span><br><span class="line">+-------------------+---------------+--------+------+--------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>例如这张学生表，此时假设以 classes 班级字段、class_adviser 班主任字段、name 学生姓名字段，组合成一个联合主键，在这里我们可以通过联合主键，确定学生表中任何一个学生的信息，比如：</p>
<blockquote>
<p>熊竹老师管的计算机 - 2201 班，哪个竹子同学有多高啊？<br>对于这个问题，可以通过上述的联合主键精准定位到表中第一条数据，并且最终能够给出答案为 185cm。</p>
</blockquote>
<p>当然，在这里有小伙伴有疑惑，为什么这三个字段可以组成联合主键，和其他字段，例如身高、性别就不行呢？因为主键一般都是用于区分不同行数据的，必须要确保唯一性，假设以「班级、班主任、性别」三个字段作为联合主键，此时能通过这个联合主键精准定位到每一条数据吗？答案是 NO，上个例子理解：</p>
<blockquote>
<p>熊竹老师管的计算机 - 2201 班，哪个男同学有多高啊？</p>
</blockquote>
<p>现在以这个联合主键还能精准定位到每一条数据吗？不行的，因为表中有两位男同学，所以会扫描到多条数据，最终会得到 185cm、180cm 两个答案，显然「班级、班主任、性别」这三个字段具备重复性，不适合作为主键。</p>
<p>到这里，咱们分析一下，假设以「班级、班主任、学生姓名」三个字段组成联合主键，当前这张表是否符合前面的三大范式呢？</p>
<ul>
<li>第一范式：表中每列数据都不可再分，具备原子性，满足。</li>
<li>第二范式：表中每行数据都仅描述了学生信息这一种业务属性，具备唯一性，满足。</li>
<li>第三范式：除主键外，表中非主键字段之间都不存在依赖关系，具备独立性，满足。</li>
</ul>
<p>经过上述分析后，当前这张表也符合前面聊到的三大范式，但没有问题了吗？有的，在这张表中，一条学生信息中的班主任，取决于学生所在的班级，比如「竹子同学、子竹同学」在「计算机 - 2201 班」，所以它们的班主任都是「熊竹老师」，因此班主任字段其实也依赖于班级字段。那会造成什么问题呢？</p>
<ul>
<li>①当一个班级的班主任老师换人后，需要同时修改学生表中的多条数据。</li>
<li>②当一个班主任老师离职后，需要删除该老师的记录，会同时删除多条学生信息。</li>
<li>③想要增加一个班级时，同时必须添加学生姓名数据，因为主键不允许为空。</li>
</ul>
<p>通过上述分析可以明显得知，如果联合主键中的一个字段依赖于另一个字段，同样也会造成不小的问题，使得整张表的维护性变差，因此这里需要进一步调整结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `zz_classes`;</span><br><span class="line">+------------+-------------------+---------------+</span><br><span class="line">| classes_id | classes_name      | class_adviser |</span><br><span class="line">+------------+-------------------+---------------+</span><br><span class="line">|          1 | 计算机-2201班     | 熊竹老师      |</span><br><span class="line">|          2 | 金融-2201班       | 竹熊老师      |</span><br><span class="line">+------------+-------------------+---------------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_student`;</span><br><span class="line">+------------+--------+------+--------+</span><br><span class="line">| classes_id | name   | sex  | height |</span><br><span class="line">+------------+--------+------+--------+</span><br><span class="line">|          1 | 竹子   | 男   | 185cm  |</span><br><span class="line">|          2 | 熊猫   | 女   | 170cm  |</span><br><span class="line">|          1 | 子竹   | 男   | 180cm  |</span><br><span class="line">+------------+--------+------+--------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>经过结构调整后，原本的学生表则又被拆为了班级表、学生表两张，在学生表中只存储班级 ID，然后使用 classes_id 班级 ID 和 name 学生姓名两个字段作为联合主键。</p>
<blockquote>
<p>实际情况中，学生表应该有学生 ID 字段作为主键，因为同一个班级中也有可能会出现重名的现象，但这里是为了举例说明，不要纠结细节~</p>
</blockquote>
<p>此时经过调整后，目前的学生表也满足了巴斯 - 科德范式，同时对于前面列出的三个问题，调整结构后也不复存在，比如换班主任后只需要更改班级表，无需修改学生表中的学生信息；增加班级时，只需要在班级表中新增数据，也不会影响学生表。</p>
<blockquote>
<p>在这里更专业的做法，应该是对于班级表中的班主任老师信息，再进一步抽象出一张教师表。毕竟班主任字段还依旧与班级字段存在依赖关系，但班级表中的主键却是班级 ID，所以非主键字段之间存在关联，是不满足第三范式的（但这里大家清楚就好啦，我就不做了！）。</p>
</blockquote>
<p>OK，经过上述一个案例的剖析后，大家对巴斯 - 科德范式也有了全面的认知，至于它为何被叫做 3.5 范式，相信大家也能够想清楚答案，因为巴斯 - 科德范式并没有定义新的设计规范，仅是对第三范式的做了补充及完善，修正了第三范式。</p>
<blockquote>
<p>第三范式只要求非主键字段之间，不能存在依赖关系，但没要求联合主键中的字段不能存在依赖，因此第三范式并未考虑完善，巴斯 - 科德范式修正的就是这点。</p>
</blockquote>
<h2 id="2-2、第四范式（4NF）"><a href="#2-2、第四范式（4NF）" class="headerlink" title="2.2、第四范式（4NF）"></a>2.2、第四范式（4NF）</h2><p>认识了巴斯 - 科德范式后，再来看看数据库的第四范式，第四范式是基于 BC 范式之上的，但在理解第四范式之前，首先得理解 “多值依赖” 的概念，先贴一下学术论文中常见的定义：</p>
<p><img src="https://pic4.zhimg.com/v2-26727d186138101d2a3475e5bdf1bcdf_r.jpg"></p>
<blockquote>
<p>论文来源于：《道客巴巴 - 多值依赖》，大部分网上资料的描述也都来自于这些学术论文。</p>
</blockquote>
<p>能看明白嘛？看不明白就对了，对于这种概念看起来确实令人头大，没有相关的技术知识储备，就算挠破头皮也看不懂这段描述，因此简单说一下什么叫做多值依赖：</p>
<blockquote>
<p>一个表中至少需要有三个独立的字段才会出现多值依赖问题，多值依赖是指表中的字段之间存在一对多的关系，也就是一个字段的具体值会由多个字段来决定。</p>
</blockquote>
<p>这样写出来似乎比前面好理解一些了，但相对来说还是很绕，那就再上个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `zz_user_role_permission`;</span><br><span class="line">+-----------+----------+-------+------------+</span><br><span class="line">| user_name | user_sex | role  | permission |</span><br><span class="line">+-----------+----------+-------+------------+</span><br><span class="line">| 竹子      | 男       | ROOT  | *          |</span><br><span class="line">| 熊猫      | 女       | ADMIN | BACKSTAGE  |</span><br><span class="line">| 竹子      | 男       | ADMIN | BACKSTAGE  |</span><br><span class="line">| 熊猫      | 女       | USER  | LOGIN      |</span><br><span class="line">| 竹子      | 男       | USER  | LOGIN      |</span><br><span class="line">| 子竹      | 男       | USER  | LOGIN      |</span><br><span class="line">+-----------+----------+-------+------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上述是一个经典的业务，也就是一张用户角色权限表，先简单介绍一下表中各字段的信息：</p>
<ul>
<li>user_name 字段 – 用户名</li>
<li>role 字段 – 角色信息： USER：普通用户角色。 ADMIN：管理员角色。 ROOT：超级管理员角色。</li>
<li>permission 字段 – 权限信息： <em>：超级管理员拥有的权限级别，</em> 表示所有。 BACKSTAGE：管理员拥有的权限级别，表示可以操作后台。 LOGIN：普通用户拥有的权限级别，表示可以登录访问平台。</li>
</ul>
<p>理解各字段的值后，假设以「用户名、角色、权限」三个字段作为联合主键，先来分析一下这张表是否满足之前的范式：</p>
<ul>
<li>表中每列数据都不可再分，具备原子性，满足第一范式。</li>
<li>表中数据都仅描述了用户权限这一种业务属性，具备唯一性，满足第二范式。</li>
<li>除主键外，表中其他字段不存在依赖关系，具备独立性，满足第三范式。</li>
<li>联合主键中的用户、角色、权限都为独立字段，不存在依赖性，满足 BC 范式。</li>
</ul>
<p>因为表中除开联合主键外，就剩下了一个性别字段，因此非主键字段必然是独立的，所以满足第三范式，但对于 BC 范式仅是勉强满足，因为「用户、角色、权限」之间存在一些依赖关系，不过这里先不管，毕竟是举例说明，因此假设是满足 BC 范式。</p>
<blockquote>
<p>上述的表结构介绍清楚后，现在来聊聊什么叫做多值依赖。</p>
</blockquote>
<p>此时假设我们需要新增一条数据，那表中的权限字段究竟填什么？这个值是需要依赖多个字段决定的，权限来自于角色，而角色则来自于用户。也就是说，一个用户可以拥有多个角色，同时一个角色可以拥有多个权限，所以此时咱们无法单独根据用户名去确定权限值，权限值必须依赖用户、角色两个字段来决定，这种一个字段的值取决于多个字段才能确定的情况，就被称为多值依赖。</p>
<blockquote>
<p>到这里是不是就理解了多值依赖？再举个例子，也就是网上经典的例子。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `zz_course_scheduling`;</span><br><span class="line">+--------+--------------+---------------------------+</span><br><span class="line">| course | teacher      | book                      |</span><br><span class="line">+--------+--------------+---------------------------+</span><br><span class="line">| 语文   | 竹熊老师     | 人教版-新课标教材         |</span><br><span class="line">| 语文   | 黑竹老师     | 人教版-现行教材           |</span><br><span class="line">| 语文   | 竹熊老师     | 北师大版教材              |</span><br><span class="line">| 数学   | 熊竹老师     | 人教版-新课标教材         |</span><br><span class="line">| 英语   | 黑熊老师     | 人教版-新课标教材         |</span><br><span class="line">+--------+--------------+---------------------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上述是一张教师排课表，分别有课程、老师、教材三个字段，一个课程会有多位老师授课，同时一个课程也会有多个版本的教材，因此在这里也是相同的，我们无法只根据课程字段决定教材字段的值，而是要结合课程、老师两个字段，才能确定教材字段的值，此时教材字段也存在多值依赖的问题。</p>
<blockquote>
<p>再经过一个案例的熏陶后，是不是对多值依赖的概念理解更深刻啦~</p>
</blockquote>
<p>到这里为止，多值依赖的概念就讲清楚了，也正是由于多值依赖的情况出现，又会导致表中出现时数据冗余、新增、删除异常等问题出现。</p>
<blockquote>
<p>因此第四范式的定义就是要消除表中的多值依赖关系。怎么做呢？拿前面的权限表举例。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `zz_users`;</span><br><span class="line">+---------+-----------+----------+----------+---------------------+</span><br><span class="line">| user_id | user_name | user_sex | password | register_time       |</span><br><span class="line">+---------+-----------+----------+----------+---------------------+</span><br><span class="line">|       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |</span><br><span class="line">|       2 | 竹子      | 男       | 1234     | 2022-09-14 16:17:44 |</span><br><span class="line">|       3 | 子竹      | 男       | 4321     | 2022-09-16 07:42:21 |</span><br><span class="line">+---------+-----------+----------+----------+---------------------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_roles`;</span><br><span class="line">+---------+-----------+---------------------+</span><br><span class="line">| role_id | role_name | created_time        |</span><br><span class="line">+---------+-----------+---------------------+</span><br><span class="line">|       1 | ROOT      | 2022-08-14 15:12:00 |</span><br><span class="line">|       2 | ADMIN     | 2022-08-14 15:12:00 |</span><br><span class="line">|       3 | USER      | 2022-08-14 15:12:00 |</span><br><span class="line">+---------+-----------+---------------------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_permissions`;</span><br><span class="line">+---------------+-----------------+---------------------+</span><br><span class="line">| permission_id | permission_name | created_time        |</span><br><span class="line">+---------------+-----------------+---------------------+</span><br><span class="line">|             1 | *               | 2022-08-14 15:12:00 |</span><br><span class="line">|             2 | BACKSTAGE       | 2022-08-14 15:12:00 |</span><br><span class="line">|             3 | LOGIN           | 2022-08-14 15:12:00 |</span><br><span class="line">+---------------+-----------------+---------------------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_users_roles`;</span><br><span class="line">+----+---------+---------+</span><br><span class="line">| id | user_id | role_id |</span><br><span class="line">+----+---------+---------+</span><br><span class="line">|  1 |       1 |       1 |</span><br><span class="line">|  2 |       1 |       2 |</span><br><span class="line">|  3 |       1 |       3 |</span><br><span class="line">|  4 |       2 |       2 |</span><br><span class="line">|  5 |       2 |       3 |</span><br><span class="line">|  6 |       3 |       3 |</span><br><span class="line">+----+---------+---------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM `zz_roles_permissions`;</span><br><span class="line">+----+---------+---------------+</span><br><span class="line">| id | role_id | permission_id |</span><br><span class="line">+----+---------+---------------+</span><br><span class="line">|  1 |       1 |             1 |</span><br><span class="line">|  2 |       2 |             2 |</span><br><span class="line">|  3 |       3 |             3 |</span><br><span class="line">+----+---------+---------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>观察上述的五张表，如果有做过权限设计，或用过 Shiro 框架的小伙伴应该会感到额外的亲切，这个正是大名鼎鼎的权限五表，将原本的用户角色权限表，拆分成了用户表、角色表、权限表、用户角色关系表、角色权限关系表。经过这次拆分之后，一方面用户表、角色表、权限表中都不会有数据冗余，第二方面无论是要删除亦或新增一个角色、权限时，都不会影响其他表。</p>
<blockquote>
<p>后面的两张关系表，主要是为了维护用户、角色、权限三者之间的关系。</p>
</blockquote>
<p>对于前面的教师排课表，就不再拆分啦，大家如若想要锻炼一下掌握程度，可自行将其拆分成符合第四范式的表结构。</p>
<h2 id="2-3、第五范式（5NF）-x2F-完美范式"><a href="#2-3、第五范式（5NF）-x2F-完美范式" class="headerlink" title="2.3、第五范式（5NF）&#x2F; 完美范式"></a>2.3、第五范式（5NF）&#x2F; 完美范式</h2><p>了解了第四范式后，再来看看第五范式，这个范式也被称为完美范式，先来说一下第五范式的定义：<strong>建立在 4NF 的基础上，进一步消除表中的连接依赖，直到表中的连接依赖都是主键所蕴含的</strong>。等等，连接依赖又是个啥？</p>
<p><img src="https://pic4.zhimg.com/v2-78f17064a4291bf2bde99bf29c325e4f_r.jpg"></p>
<blockquote>
<p>看不懂对不？说实话我也看着迷糊，大概能确定的是：多值依赖也属于连接依赖的一种，而连接依赖也包含了多值依赖。</p>
</blockquote>
<p>第五范式解决的是无损连接问题，但对于第五范式我自个儿也没理解透彻，因此不再讲解第五范式了，防止误导诸位，同时如若有对这块十分了解的大佬，可以留言指点一下。</p>
<h2 id="2-4、六大范式小结"><a href="#2-4、六大范式小结" class="headerlink" title="2.4、六大范式小结"></a>2.4、六大范式小结</h2><p>经过一系列的阐述后，其实不难发现，越到后面的范式，越难令人理解，同时为了让表满足更高级别的范式，越往后付出代价也越大，而且拆分出的表数量也会越多，所以一般实际开发中，对于库表的设计最高满足 BC 范式即可，再往后就没意义了，因为表数量一多，查询也好，写入也罢，性能会越来越差。</p>
<blockquote>
<p>同时，由于后面的几种范式在实际项目中应用较少，因此关于这块的资料也会较少，后续的几种范式也仅有一些学术机构在琢磨，所以当我们试图去窥探时，能看到的也是一堆学术词汇。</p>
</blockquote>
<p>除开聊到的六大范式外，还有一种范式名为域键范式，也被称之为终极范式，但目前也仅有学术机构在研究，在生产环境中实际的用途也不大，诸位有兴趣可以自己看看，最后再上一个各范式之间的递进关系图：</p>
<p><img src="https://pic4.zhimg.com/v2-490230ba2efebb1c924891092bbc990b_r.jpg"></p>
<ul>
<li>第一范式：原子性，每个字段的值不能再分。</li>
<li>第二范式：唯一性，表内每行数据必须描述同一业务属性的数据。</li>
<li>第三范式：独立性，表中每个非主键字段之间不能存在依赖性。</li>
<li>巴斯范式：主键字段独立性，联合主键字段之间不能存在依赖性。</li>
<li>第四范式：表中字段不能存在多值依赖关系。</li>
<li>第五范式：表中字段的数据之间不能存在连接依赖关系。</li>
<li>域键范式：试图研究出一个库表设计时的终极完美范式。</li>
</ul>
<h2 id="三、数据库反范式设计"><a href="#三、数据库反范式设计" class="headerlink" title="三、数据库反范式设计"></a>三、数据库反范式设计</h2><p>遵循数据库范式设计的结构优点很明显，它避免了大量的数据冗余，节省了大量存储空间，同时让整体结构更为优雅，能让 SQL 操作更加便捷且减少出错。但随着范式的级别越高，设计出的结构会更加精细化，原本一张表的数据会被分摊到多张表中存储，表的数量随之越来越多。</p>
<p>但随之而来的不仅仅只有好处，也存在一个致命问题，也就是当同时需要这些数据时，只能采用联表查询的形式检索数据，有时候甚至为了一个字段的数据，也需要做一次连表查询才能获得。这其中的开销无疑是花费巨大的，尤其是当连接的表不仅两三张而是很多张时，有可能还会造成索引失效，这种情况带来的资源、时间开销简直是一个噩梦，这会严重地影响整个业务系统的性能。</p>
<blockquote>
<p>因此，也正是由于上述一些问题，在设计库表结构时，我们不一定要 100% 遵守范式准则。这种违反数据库范式的设计方法，就被称之为 反范式设计。</p>
</blockquote>
<p>遵循范式设计也好，反范式设计也罢，本身两者之间并没有优劣之分，只要能够对业务更有利，那就可以称之为好的设计方案。范式的目的仅在于让我们设计的结构更优雅合理，有时候在表中多增加一个字段，从数据库的角度来看，数据会存在冗余问题，会让表结构违反范式的定义，但如若能够在实际情况中减少大量的连表查询，这种设计自然也是可取的。</p>
<blockquote>
<p>也就是说，在设计时千万不要拘泥于规则之内，一定要结合实际业务考虑，遵循业务优先的原则去设计结构。</p>
</blockquote>
<p>当然，对于反范式设计也无需再用更多的语言去描述了，因为本质上就是一个概念词，也就是不遵循数据库范式设计的结构，就被称为反范式结构。不过要牢记的一点是：不是所有不遵循数据库范式的结构设计都被称为反范式，反范式设计是指自己知道会破坏范式，但对业务带来好处大于坏处时，刻意设计出破坏范式的结构。</p>
<blockquote>
<p>随意设计出的结构，不满足范式要求，同时还无法给业务上带来收益的，这并不被称为反范式设计，反范式设计是一种刻意为之的思想。</p>
</blockquote>
<h2 id="四、库表设计篇总结"><a href="#四、库表设计篇总结" class="headerlink" title="四、库表设计篇总结"></a>四、库表设计篇总结</h2><p>在本篇中详细阐述了 DB 库表设计时的一些思想，也就是范式与反范式设计理论，这些理论仅仅只是一套方法论，实际开发过程中，还是需要根据业务来设计出最合适的结构。在文中提及了六种范式，但一般项目中仅需满足到第三范式或 BC 范式即可，因为这个度刚刚好，再往后就会因为过于精细化设计，导致整体性能反而下降。控制到第三范式的级别，一方面数据不会有太多冗余，第二方面也不会对性能影响过大。</p>
<blockquote>
<p>同时，如若打破范式的设定能对业务更有利，那也可以违背范式原则去设计。</p>
</blockquote>
<p>不过虽说这些属于方法论，但认真看下来之后，相信诸位在之后设计库表结构应该会潜意识的遵循一些范式原则，也会尽量的将表结构设计的更为优雅，从而也能让咱们在开发过程中，减少调整库表结构的次数和带来的影响。</p>
<blockquote>
<p>一般而言，库表结构设计的是否合理，区别如下：</p>
</blockquote>
<ul>
<li>不合理的结构设计会造成的问题： 数据冗余，会浪费一定程度上的存储空间 不便于常规 SQL 操作（例如插入、删除），甚至会出现异常</li>
<li>合理的结构设计带来的好处： 节省空间，SQL 执行时能节省内存空间，数据存储时能节省磁盘空间 数据划分较为合理，DB 性能整体较高，并且数据也非常完整 结构便于维护和进行常规 SQL 操作</li>
</ul>
]]></content>
      <tags>
        <tag>数据库，范式</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之模型的评估与优化</title>
    <url>/2024/02/28/%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>当已经用现有机器学习算法（神经网络、决策树、逻辑回归等）构建了一个机器学习模型，但是模型的效果不是那么好，或者说我们想进一步优化这个模型时，我们可以怎么做呢？</p>
</blockquote>
<hr>
<p>比如我们的损失函数:</p>
<p><img src="/./img/2_22_1.png" alt="image-20240222203844644"></p>
<p>其中$\lambda$是正则化系数，我们可以尝试这些方法：</p>
<ol>
<li>扩大训练样本</li>
<li>缩小特征变量维数</li>
<li>增加特征变量维数</li>
<li>增加拟合模型阶数</li>
<li>增大正则化系数</li>
<li>减小正则化系数</li>
</ol>
<p>但是什么时候用什么方法呢？我们首先学习如何评估一个模型。</p>
<p>不管是回归问题还是分类问题，我们都有一个损失函数$J(\vec{w},b)$。我们要做的是最小化这个损失函数。我们通常将数据分割成 <strong>训练集</strong>和<strong>测试集</strong>两部分，通常是7:3的比例。然后分别在训练集和测试集上分别计算损失函数，如果两者最后都很小，那么可以说这个模型是有效的。（如果不是很离谱的模型，训练集上的误差大概率最后都比较小，重点看的是测试集的误差，the loss of the test data is a better indicator）</p>
<hr>
<blockquote>
<p> 为什么需要测试集？</p>
</blockquote>
<p>第一是我们需要知道模型面对未知数据的能力，不能只拿训练集的误差来衡量模型好坏，因为这些数据是用来训练的，是与调优的模型相关的数据，是“已经见过的数据”，这就好比女朋友提问她好不好看，如果要追求最客观公正的答案，那么就不能由男朋友来回答，而是要找很多路人来回答。</p>
<p>还有一点就是防止模型过拟合，<strong>模型可能学会了训练数据的噪声</strong>，而没有学到数据的真实分布，表现在误差上就是训练集误差非常小，这时我们可以通过看测试集误差来检查是否有过拟合的现象。</p>
<hr>
<p>对于分类问题，除了传统意义上的损失函数计算方法外（比如逻辑回归的熵计算法），还可以用<strong>训练集和测试集中错误分类的比例</strong>来反映模型的效果。</p>
<hr>
<blockquote>
<p>为什么不能直接拿测试集中的数据去进行模型选择？</p>
</blockquote>
<p>测试集的目的是检验模型面对未知的新数据的能力，如果用测试集数据干预了模型选择的过程，那么测试集中的数据就会被“污染”。换句话说，这种行为就是在询问亲近的兄弟：我女朋友美不美，也得不出客观的评价。</p>
<hr>
<p>最终解决方案：训练集 + 交叉验证集 + 测试集（6:2:2）</p>
<p>其中训练集用来训练模型参数，交叉验证集用来衡量模型性能，用于模型选择，测试集用来测试模型对未知数据的预测能力。流程如下：</p>
<p><img src="/./img/2_22_2.png" alt="image-20240222215600272"></p>
<p>但是假设有这样一种情况：这个模型相比其他模型好一些，但是在训练集和测试集上的误差都比较大，表现都不尽如人意，我们应该如何调整模型呢？</p>
<p>我们先来了解一下两种极端的现象：高偏差(High bias)和高差异(High variance)</p>
<ul>
<li>如果$J(train)$和$J(cv)$都比较高，那么模型表现为High bias</li>
<li>如果$J(train)$比较低，但$J(cv)$很高，那么模型表现为High variance</li>
<li>还有一种情况可能既High bias 又 High variance，一般会在神经网络中出现，但这种现象并不常见</li>
</ul>
<p><img src="/./img/2_22_3.png" alt="image-20240222222544928"></p>
<p><img src="/./img/2_22_4.png" alt="image-20240222223518403"></p>
<p>多项式系数和正则化系数都可以影响模型的偏差和差异，具体曲线如下图：</p>
<blockquote>
<p>回忆：正则化是通过引入惩罚系数$\lambda$来调整模型的高次项参数，从而一定程度上解决过拟合的问题，因为如果惩罚系数比较大的话，高次项系数就会比较小，模型的“弯曲程度”就会减小，过拟合的风险就会降低。</p>
</blockquote>
<p><img src="/./img/2_22_5.png" alt="image-20240222223544847"></p>
<blockquote>
<p>那么什么样的$J(train)$和$J(cv)$可以被称为“大”呢？</p>
</blockquote>
<p>我们需要找一个基准(baseline)去了解这个问题，通过对比baseline和$J(train)$，我们可以判断是不是High bias；通过对比$J(train)和$$J(cv)$我们可以判断是不是High viriance.</p>
<p><img src="/./img/2_22_6.png" alt="image-20240222224604141"></p>
<p>我现在想知道，增大训练样本数量对提升模型效果有没有用，这就引出了“学习曲线”的概念。学习曲线是$J(train)$和$J(cv)$随着训练样本数的增大而改变的曲线，一般来说长这样：</p>
<p><img src="/./img/2_22_8.png" alt="image-20240224122846083"></p>
<p>当训练样本数量很小时，因为模型没有足够的数据学习到真实的分布，所以$J(cv)$很高，但是模型很好地拟合了所给的数据，所以$J(train)$比较低。</p>
<p>当样本的数量不断增大时，这是模型慢慢很好地学习了模型的真实分布，$J(cv)$不断减小，但是由于数据的真实分布越来越难用当前模型拟合，所以每增加一个训练数据，其实就给$J(train)$引入了新的误差，所以$J(train)$在不断增大。</p>
<p>我们说比较$J(train)$和baseline可以看出模型是否高偏差。比较$J(train)$和$J(cv)$可以看出模型是否过拟合。从这张图可以看出模型是否过拟合，如果训练的$J(train)$和$J(cv)$相差比较大，那么模型就有过拟合的问题，这时候通过增加训练样本数量可以解决过拟合问题，让模型更好地学习真实的数据分布。</p>
<p><img src="/./img/2_22_11.png" alt="image-20240224145120222"></p>
<p>但是如果$J(train)$比baseline大很多的话，就属于高偏差的问题，这时候通过增大样本数量就不会起什么作用了。这时候就需要更换模型来解决问题了？</p>
<p><img src="/./img/2_22_10.png" alt="image-20240224145024442"></p>
<p>现在，我们可以通过识别是High bias或者High variance来挑选上述6种方法对模型进行调整了。</p>
<ol>
<li>扩大训练样本 – 针对High variance</li>
<li><mark>缩小特征变量维数</mark> – 针对High variance</li>
<li><mark>增加特征变量维数</mark> – 针对High bias</li>
<li>增加拟合模型阶数. – 针对High bias</li>
<li>增大正则化系数 – 针对High variance</li>
<li>减小正则化系数 – 针对High bias</li>
</ol>
<p>对于神经网络来说，上面的理论仍然适用，并且神经网络的优点之一就是可以作为一个很好的方式解决High bias和High variance。基本流程如下：</p>
<p><img src="/./img/2_22_12.png" alt="image-20240224152239930"></p>
<p>首先看模型是不是High bias，如果是的话就增大网络复杂度，可以增加隐藏层或者增大每一层的神经元数，直到模型表现良好（和baseline相比），然后需要检查$J(cv)$，如果$J(cv)$太大的话需要扩大样本数量，然后需要重新判断模型是不是高偏差，如此循环往复，直到High bias和High variance都解决为止。</p>
<p>当然，正则化在神经网络中的作用也是很大的。事实表明，只要正确地选取正则化系数，复杂的神经网络架构+正则化总是比简单神经网络表现出色，缺点就是复杂的神经网络消耗算力较大，硬件成本较大。</p>
<blockquote>
<p>拓展知识：迁移学习</p>
</blockquote>
<p>迁移学习指的是用已经训练好的模型参数来训练相似的任务。它包括两个步骤：</p>
<ol>
<li>supervised pretraining 迁移预训练。首先在一个大数据集上训练一个任务，获得其最终的模型参数</li>
<li>Fine-tuning。 然后使用训练好的模型参数作为初始参数来训练另一个任务。这里有两种方法，第一种是只训练最后一层的参数，这个适合当前只有小数据集，第二种方法是把模型参数全部再训练一遍，这种方法适合有相对较大的数据集。不管哪种方法，训练的效率都比从0开始训练快得多。</li>
</ol>
<p>‼️能够进行迁移学习的重要依据是任务之间共享表示，比方说图像识别任务，都需要识别图片的形状、边缘、纹理等特征。如果任务之间没有足够的相似性，迁移学习并不能提高性能。</p>
<blockquote>
<p> 拓展知识：精确率(precision)和召回率 (recall)</p>
</blockquote>
<p>先来看混淆矩阵：</p>
<p><img src="/./img/2_22_14.png" alt="image-20240228144656795"></p>
<p><strong>精确率precision</strong>：实际和预测同时为正例 &#x2F; 预测值全部为正例</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/hflWRBRSEZ5r9kqF9Ricy7qmqzfMwWdeF8ibycCcXCLYPc3fEInVN3benYLmMkTqjVMSZ3emS8ThTsMibNyEfQ17w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>召回率recall</strong>：实际和预测同时为正例 &#x2F; 实际值全部为正例</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/hflWRBRSEZ5r9kqF9Ricy7qmqzfMwWdeFAGTB4BFKmHTSn3vUVu7IInV4Q3ic2siaUSMCJRh3aocsKa4KiaFJxic7bA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>精确率和召回率是一对矛盾的量，一个高的话，另一个必定低，关系图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/hflWRBRSEZ5r9kqF9Ricy7qmqzfMwWdeFEMwcfJQPuRzwc0qbMKicMJ0sVNHiaYyEd7Xa4KiayznA3RuDfM9viaibujg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>把threshould调高之后，找出来的正例是真正的正例的概率提高了，但是漏网之鱼变多了，就是说真正是正例，但是没找出来，总结来说就是“找到了，但没完全找到”。用捕鱼的例子，网的孔隙变大了，有些鱼就抓不到了。</p>
<p>把threshould调低之后，真正的正例就更容易被识别出来了，但是因为判断正例的标准变低了，所以很多真实的负例也会被筛选出来判断为正例，总结来说就是“宁可错杀一千，也不放过一人”。用捕鱼的例子，就是孔隙变小了，一些小鱼小虾也会被捞上来了，但是捞上来的肯定有我们想要的鱼。</p>
<p>那么如何确定孔隙大小呢？精确率和召回率之间的平衡点，一般是使用<strong>F1系数</strong>表示。这种加分之乘形式的函数很适合用来表征有反相关关系的两个变量之间的最优化问题，只要最大化这个函数的值就可以找到一个令两个变量都高的一个平衡点。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/hflWRBRSEZ5r9kqF9Ricy7qmqzfMwWdeFzfbyZSzweqxGNFGEuIOA1yGtibY0RzHpBMjTpelCTYp96eBRnnYBAmA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Day1 数组基础</title>
    <url>/2023/08/24/%E7%AC%AC%E4%B8%80%E5%A4%A9%20%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%20Part1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>二分查找适用于有序数组中的元素查找，时间复杂度为O(logn)，根据右指针设置的不同可以有两种不同的写法。</p>
<p><mark>第一种也是我主要记忆的方法就是左闭右闭区间查找</mark>，右指针指向<code>nums.size() - 1</code>，这种方法的重要特征是循环条件<code>while(l &lt;= r)</code>, 当左边与右边相等时是有比较意义的，因为本来就需要看两边的值。<br>这种实现方式的C++代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num[mid] &lt; target)&#123;</span><br><span class="line">			r = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			l = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种就是采用左闭右开的方法，将右指针指向数组最后一个元素的下一位。采用这种方式，当l $&#x3D;$ r时再比较是没有意义的，所以只需<code>while(l &lt; r)</code>即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(); <span class="comment">// 注意这里的r和之前不同了</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			r = mid;  <span class="comment">// 注意这里的r的更新不同了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a> 修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>这道题需要思考如何用<strong>线性的时间复杂度</strong>去解决问题，为此我们需要从前向后扫描数组，在发现val元素时及时移动数组元素，这样就可以达到线性的时间复杂度。</p>
<p>然后可以注意到，从左向右扫描元素的过程中，非val元素需要往左边移动的格子数从0一直累加自增，每发现一个val元素就会增加1，所以这里引出第一种方法：<strong>记录移动位置数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>; <span class="comment">// 记录后续元素的偏移量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] == val)&#123;</span><br><span class="line">			offset++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i - offset] = nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums.<span class="built_in">size</span>() - offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>还有一种很巧妙但很常用的方法，那就是使用快慢双指针进行求解，<mark>快指针用来遍历数组判断条件，慢指针用来记录新数组更新的位置</mark>,因为快指针永远不会落后于慢指针，所以慢指针的更新不会影响到快指针的判断。下面是代码，非常简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fp = <span class="number">0</span>, sp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (fp; fp &lt; nums.<span class="built_in">size</span>(); fp++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[fp] == val) <span class="keyword">continue</span>;</span><br><span class="line">		nums[sp++] = nums[fp];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Day3 链表基础</title>
    <url>/2023/08/28/%E7%AC%AC%E4%B8%89%E5%A4%A9%20%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%20Part1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>此题考查链表的删除操作，设置一个虚拟头节点指向第一个节点，这样就可以统一删除操作了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">	<span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* hn = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="comment">// 通过虚拟节点的方式实现删除操作</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode* tn = hn; tn &amp;&amp; tn-&gt;next; tn=tn-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (tn-&gt;next &amp;&amp; tn-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* dn = tn-&gt;next;</span><br><span class="line">                tn-&gt;next = tn-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> dn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hn-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意for循环里的判断条件<code>tn &amp;&amp; tn-&gt;next</code>，当while循环执行完毕时tn-&gt;next可能会是nullptr，这时for循环会执行tn &#x3D; tn-&gt;next，使得tn变为nullptr，所以这时需要判断tn是否为nullptr。除了这种特殊情况是用tn来判断，其他都是用tn-&gt;next来判断是否结束循环。</p>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
<h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><p>这题考查对链表的底层理解和实现，为了操作简便我们设置了一个虚拟头节点，这个头节点指向链表的第一个节点，这样无论输入链表是不是空，类属性head都存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> v):<span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        sz = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz == <span class="number">0</span> || index &lt; <span class="number">0</span>  || index &gt;= sz)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode* tn;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>,tn = head-&gt;next; i &lt; index;i++, tn=tn-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> tn-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* nn = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        nn-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = nn;</span><br><span class="line">        sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* nn = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode* tn;</span><br><span class="line">        <span class="keyword">for</span> (tn = head; tn-&gt;next; tn=tn-&gt;next);</span><br><span class="line">        tn-&gt;next = nn;</span><br><span class="line">        sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; sz)   <span class="keyword">return</span>;</span><br><span class="line">        ListNode* tn = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++, tn=tn-&gt;next);</span><br><span class="line">        ListNode* nn = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        nn-&gt;next = tn-&gt;next;</span><br><span class="line">        tn-&gt;next = nn;</span><br><span class="line">        sz++;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= sz)   <span class="keyword">return</span>;</span><br><span class="line">        ListNode* tn = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++, tn=tn-&gt;next);</span><br><span class="line">        ListNode* dn = tn-&gt;next;</span><br><span class="line">        tn-&gt;next = tn-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dn;</span><br><span class="line">        sz--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* head;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是addAtIndex方法的边界判断，当index &#x3D;&#x3D; size时表示在整个链表末尾加元素，这点和deleteAtIndex是不同的。</p>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p>
<h3 id="思路解析-2"><a href="#思路解析-2" class="headerlink" title="思路解析"></a>思路解析</h3><p>这题是典型的双指针题型，需要设置<strong>一前一后指针</strong>，前指针是遍历指针，用来倒转next指针指向，后指针是用来记录倒转指针指向位置的，此外还需要设置一个局部临时指针变量，这个指针的作用是<strong>暂存前指针原先的next指针</strong>，让遍历得以完成。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* fp = head-&gt;next;  <span class="comment">// 前指针</span></span><br><span class="line">        ListNode* bp = head;  <span class="comment">// 后指针</span></span><br><span class="line">        bp-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">// 需要将头节点的next指针先置null</span></span><br><span class="line">        <span class="keyword">while</span>(fp)&#123;</span><br><span class="line">            ListNode* tp = fp-&gt;next; </span><br><span class="line">            fp-&gt;next = bp;</span><br><span class="line">            bp = fp;</span><br><span class="line">            fp = tp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Day2 数组基础</title>
    <url>/2023/08/25/%E7%AC%AC%E4%BA%8C%E5%A4%A9%20%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%20Part2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>此题很容易想到暴力解法，只需要先平方再排序即可，但是那样的话时间复杂度最快是<code>O(nlogn)</code>，不够好，像这样的题追求的基本都是线性的时间复杂度。</p>
<p>注意到对于非负值来说，其原来的顺序就是平方后的顺序，可能改变的就是负数平方之后会插入在这些非负数平方之间。另外，<mark>负数越小，平方之后就越大，插入的位置就越往后。</mark>所以我们想到用双指针的方法，设置<strong>一前一后两个指针，前指针指向要插入的负数，后指针指向负数平方后将要插入的位置。</strong></p>
<p>基本的代码逻辑是，右指针不断向左移动找插入位置，左指针一个个插入右指针找好的位置，直到左指针与右指针相遇后<strong>传入最后一个值</strong>随后退出循环。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pl = <span class="number">0</span>, pr = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (pl &lt;= pr)&#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[pr] &gt; <span class="built_in">abs</span>(nums[pl])) &#123;</span><br><span class="line">			ans[k--] = nums[pr] * nums[pr];</span><br><span class="line">			pr--;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 此时pr指向第一个小于或等于pl指向的绝对值的值</span></span><br><span class="line">		ans[k--] = nums[pl] * nums[pl];</span><br><span class="line">		pl ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>while (pl &lt;= pr)</code>以及<code>nums[pr] &gt; abs(nums[pl])</code>的符号差异，后者保证循环下来pr指<mark>最大的小于或等于abs(nums[pl])</mark>的值，前者保证当首尾指针交叉时数据会被写入新数组。</p>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的<strong>连续</strong>子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<ul>
<li>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</li>
<li>输出：2</li>
<li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li>
</ul>
<h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><p>此题需要注意的一个很重要的点是<strong>连续</strong>，刚开始没注意连续，想着直接给数组排序了。如果是连续的话，就需要设置指针来探究了。暴力法很好想，全部元素遍历一遍，对于每一个遍历的元素都求一个连续子数组，记录这个过程中的最小数组长度即可。</p>
<p>但是本题可以用<strong>双指针</strong>的方法实现<strong>线性</strong>的时间复杂度，昨天的消除连续指针是用快慢指针，上一题是用双向指针，这里因为需要求区间长度，所以想到用两个指针维护一个“窗口”。从左到右滑动这个窗口，我们设置右指针为遍历指针，然后利用<strong>贪心思想</strong>，左指针每次都指向能满足条件的最大下标处，通过这样的方式来计算出<strong>最短的区间</strong>。</p>
<img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" > 


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> minLen = INT32_MAX;</span><br><span class="line">	<span class="keyword">for</span>(r;r &lt; nums.<span class="built_in">size</span>();r++)&#123;</span><br><span class="line">		sum += nums[r];</span><br><span class="line">		<span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line">			sum -= nums[l++]; <span class="comment">// 贪心右移</span></span><br><span class="line">			minLen = minLen &lt; (r - l + <span class="number">1</span> + <span class="number">1</span>)?minLen:(r-l+<span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minLen == INT32_MAX?<span class="number">0</span>:minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的贪心右移是精髓，其实反过来，把左边的指针作为遍历指针，右边的指针作为贪心指针也可以，所以说这种双指针的思想就是<strong>一个遍历指针，一个贪心指针</strong>。</p>
<h2 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg"></p>
<h3 id="思路解析-2"><a href="#思路解析-2" class="headerlink" title="思路解析"></a>思路解析</h3><p>此题没有涉及算法，主要是模拟过程，其中涉及很多边界判断，需要细心发掘规律，耐心编程即可。</p>
<p>当n为3的时候，首先将外圈填完，可以看到最终填入的数字是$n^2 - 1$,然后填$n^2$;当n $&#x3D;$ 5时,首先填外圈(边长为5)，然后填边长为3的内圈(起点是(1,1))，最后填边长为1的格子。</p>
<p>由此可以发现规律，边长逐渐变小，每次减2，起点逐渐增大，每次递增1，并且<mark>只要确定了边长和起点，就可以确定该圈填入的所有数字</mark>,可以根据这一点来写循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">	<span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i-=<span class="number">2</span>,st++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> offs = st; offs &lt; st + i; offs++)</span><br><span class="line">			ans[st][offs] = ++k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> offs = st + <span class="number">1</span>; offs &lt; st + i; offs++)</span><br><span class="line">			ans[offs][st + i - <span class="number">1</span>] = ++k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> offs = st + i - <span class="number">1</span> - <span class="number">1</span>; offs &gt;= st; offs--)</span><br><span class="line">			ans[st + i - <span class="number">1</span>][offs] = ++k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> offs = st + i - <span class="number">1</span> - <span class="number">1</span>; offs &gt; st; offs--)</span><br><span class="line">			ans[offs][st] = ++k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要额外注意的是，在我们以<strong>右-下-左-上</strong>的顺序填入的时候，当向右填完后不能从行为st开始填，这样会覆盖掉刚刚填的内容，需要从st + 1开始，其他方向同理。</p>
]]></content>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Day4 链表基础</title>
    <url>/2023/08/29/%E7%AC%AC%E5%9B%9B%E5%A4%A9%20%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%20Part2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="两两交换链表元素"><a href="#两两交换链表元素" class="headerlink" title="两两交换链表元素"></a>两两交换链表元素</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="24.两两交换链表中的节点-题意"></p>
<h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>两两交换节点必然涉及多指针操作，需要更改多个节点的next指向，并且交换是两两的，由此我想到了用双指针的方法。通过一前一后两个指针，分别指向每次交换的节点的方法来更新链表。</p>
<p>![[Pasted image 20230828234204.png]]</p>
<p>上图是一般的更新思路，但是这种方法细想，其实有很多问题。</p>
<ol>
<li>按照上图的更新方式，对于1节点来说，bp-&gt;next &#x3D; fp-&gt;next-&gt;next。但是当节点3，4不存在或4不存在的时候，这样的更新方式就会出错</li>
<li>fp和bp的更新可以通过临时节点来实现，但是还是会存在上述的问题，如何能保证不会空指针异常需要耐心调试</li>
<li>循环何时结束是需要考虑的一大问题</li>
</ol>
<p>想必读者也看出上述方式的复杂性了，<strong>因为我们没能找到一个统一的更新思想，所以当边界条件很多时避免不了分类讨论，操作会很繁琐。</strong></p>
<p>不过调试就调试呗，以下是这种实现方式的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)   <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* hn = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head-&gt;next); <span class="comment">// 头节点，方便返回</span></span><br><span class="line">        ListNode* fp = head-&gt;next;</span><br><span class="line">        ListNode* tp;</span><br><span class="line">        ListNode* bp = head;</span><br><span class="line">        <span class="keyword">while</span>(fp)&#123;</span><br><span class="line">            tp = fp-&gt;next;</span><br><span class="line">            bp-&gt;next = tp?(tp-&gt;next?tp-&gt;next:tp):<span class="literal">nullptr</span>; <span class="comment">// 分类更新，共三种情况。</span></span><br><span class="line">            fp-&gt;next = bp;</span><br><span class="line">            bp = tp;</span><br><span class="line">            fp = bp?bp-&gt;next:<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hn-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述代码中bp的更新是最难的，不过其实只有三种情况：</strong></p>
<ol>
<li>当前bp-fp对之后没有下一对了，此时更新为nullptr</li>
<li>当前bp-fp对之后只有单身狗了，此时更新为tp</li>
<li>当前bp-fp对之后还是一对，此时更新为tp-&gt;next</li>
</ol>
<p>此外fp也要根据bp的情况进行更新。</p>
<p>读者想必要问，有没有相对统一的，不用这样分类讨论的方法？<br>Carl哥给我们的方法就是相对统一的，还是上面的例子,不过我们加上头节点和一个cur指针：<br>![[Pasted image 20230828235922.png]]</p>
<p>这种方法的核心思想是：<mark>通过让cur指向需要改变的节点对的前一个节点来实现更换操作</mark>.为什么要指向前一个节点呢？如果按照我们刚刚的思想，指针指向第一个节点不行吗？</p>
<p>如果指向第一个节点，那么后面一个节点对的情况就势必会影响到这个节点对，由此带来分类讨论的问题。如果指向前一个节点，那么我们就可以找出一个更新规律：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png"></p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png"></p>
<p>最后，每次更新完链表之后还需要将cur指向下一对节点的前一个节点，上述实例中是1节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方面后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="comment">// 步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;          <span class="comment">// 步骤二</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="comment">// 步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="删除链表的倒数第n个节点"><a href="#删除链表的倒数第n个节点" class="headerlink" title="删除链表的倒数第n个节点"></a>删除链表的倒数第n个节点</h2><p>本题只需要想到使用区间双指针就会很快，如果不用虚拟头节点的话需要加上对头节点删除的条件判断，总体来说不难。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* fp = head, *bp = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++,fp=fp-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (!fp)    head = head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;fp-&gt;next;fp=fp-&gt;next,bp=bp-&gt;next);</span><br><span class="line">            bp-&gt;next = bp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png"></p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><p>首先求出两个链表的长度，然后用对齐的双指针逐一推进即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(ListNode* n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (sz; n;n=n-&gt;next,sz++);</span><br><span class="line">        <span class="keyword">return</span> sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> szA = <span class="built_in">len</span>(headA), szB = <span class="built_in">len</span>(headB);</span><br><span class="line">        ListNode* pa = headA, *pb = headB;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> offs = szA - szB &gt; <span class="number">0</span>?szA - szB:szB-szA;</span><br><span class="line">        <span class="keyword">if</span> (szA &lt; szB)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; offs; i++)  pb=pb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; offs; i++)  pa=pa-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(;pa &amp;&amp; pb; pa=pa-&gt;next,pb=pb-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pa == pb)   <span class="keyword">return</span> pa;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>既然是环形链表，就可以用<strong>环形链表的数学性质</strong>来解决。我们从头节点开始一直前进，会在环的入口处进入循环，不断地“绕圈”。如果我们设置双指针，一快一慢，<mark>两指针一定会在循环中相遇</mark>。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png"></p>
<p>设相遇时慢指针经过了$x + y$个节点，那么快指针经过了$x+n(y+z)+y$个节点，这里的n表示快指针经历的循环数。这是个追击问题，因为<strong>快指针每次走两步，慢指针每次走一步</strong>，所以有：</p>
<p>$$<br>\frac{x+y}{1} &#x3D; \frac{x + n(y+z)+y}{2}<br>$$</p>
<p>整理得：</p>
<p>$$<br>x &#x3D; (n-1)(y+z) + z, n&gt;&#x3D; 1<br>$$<br>从这个公式可以看出，所求的x就等于一个指针从相遇节点出发，转(n-1)圈然后再走z步。<strong>所以我们再设置两个指针，一个从头出发，一个从相遇节点出发，每次都走一步，相遇的地方就是所求环的入口</strong>。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fp = head, *sp = head;</span><br><span class="line">        <span class="keyword">while</span>(fp&amp;&amp;fp-&gt;next)&#123;</span><br><span class="line">            fp = fp-&gt;next-&gt;next;</span><br><span class="line">            sp = sp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(sp == fp)&#123;</span><br><span class="line">                ListNode* tp1 = head;</span><br><span class="line">                ListNode* tp2 = fp;</span><br><span class="line">                <span class="keyword">while</span>(tp1!=tp2)&#123;</span><br><span class="line">                    tp1 = tp1-&gt;next;</span><br><span class="line">                    tp2 = tp2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> tp1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列相关问题</title>
    <url>/2024/07/11/2024-7-11-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Pair基础"><a href="#Pair基础" class="headerlink" title="Pair基础"></a>Pair基础</h2><p>在C++中，<code>pair</code> 是一个常用的模板类，用来将两个值组合成一个值对。它在处理关联数据时非常有用，例如在标准库中的<code>map</code>和<code>set</code>中常用到。以下是一些<code>pair</code>的常见操作和用法：</p>
<h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><h4 id="1-创建一个pair并初始化："><a href="#1-创建一个pair并初始化：" class="headerlink" title="1. 创建一个pair并初始化："></a>1. 创建一个<code>pair</code>并初始化：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">myPair</span><span class="params">(<span class="number">1</span>, <span class="string">"Hello"</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"First: "</span> &lt;&lt; myPair.first &lt;&lt; <span class="string">", Second: "</span> &lt;&lt; myPair.second &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-使用std-make-pair函数创建一个pair："><a href="#2-使用std-make-pair函数创建一个pair：" class="headerlink" title="2. 使用std::make_pair函数创建一个pair："></a>2. 使用<code>std::make_pair</code>函数创建一个<code>pair</code>：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">"Hello"</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"First: "</span> &lt;&lt; myPair.first &lt;&lt; <span class="string">", Second: "</span> &lt;&lt; myPair.second &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p><code>pair</code>中的元素可以通过<code>first</code>和<code>second</code>成员来访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">myPair</span><span class="params">(<span class="number">1</span>, <span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"First: "</span> &lt;&lt; myPair.first &lt;&lt; <span class="string">", Second: "</span> &lt;&lt; myPair.second &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    myPair.first = <span class="number">2</span>;</span><br><span class="line">    myPair.second = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"First: "</span> &lt;&lt; myPair.first &lt;&lt; <span class="string">", Second: "</span> &lt;&lt; myPair.second &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p><code>pair</code> 支持比较操作，包括相等、不等、小于、小于等于、大于和大于等于。比较操作按字典序进行，**即先比较<code>first</code>，如果<code>first</code>相等，再比较<code>second</code>**。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">pair1</span><span class="params">(<span class="number">1</span>, <span class="string">"Hello"</span>)</span></span>;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">pair2</span><span class="params">(<span class="number">2</span>, <span class="string">"World"</span>)</span></span>;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">pair3</span><span class="params">(<span class="number">1</span>, <span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较操作</span></span><br><span class="line">    std::cout &lt;&lt; (pair1 == pair2) &lt;&lt; std::endl; <span class="comment">// 输出 0 (false)</span></span><br><span class="line">    std::cout &lt;&lt; (pair1 != pair2) &lt;&lt; std::endl; <span class="comment">// 输出 1 (true)</span></span><br><span class="line">    std::cout &lt;&lt; (pair1 &lt; pair2) &lt;&lt; std::endl;  <span class="comment">// 输出 1 (true)</span></span><br><span class="line">    std::cout &lt;&lt; (pair1 &lt;= pair3) &lt;&lt; std::endl; <span class="comment">// 输出 1 (true)</span></span><br><span class="line">    std::cout &lt;&lt; (pair2 &gt; pair1) &lt;&lt; std::endl;  <span class="comment">// 输出 1 (true)</span></span><br><span class="line">    std::cout &lt;&lt; (pair2 &gt;= pair3) &lt;&lt; std::endl; <span class="comment">// 输出 1 (true)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="使用在标准库容器中"><a href="#使用在标准库容器中" class="headerlink" title="使用在标准库容器中"></a>使用在标准库容器中</h3><p><code>pair</code> 经常在标准库容器中使用，例如<code>map</code>和<code>set</code>。</p>
<h4 id="1-在map中使用："><a href="#1-在map中使用：" class="headerlink" title="1. 在map中使用："></a>1. 在<code>map</code>中使用：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">"One"</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">"Two"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myMap) {</span><br><span class="line">        std::cout &lt;&lt; elem.first &lt;&lt; <span class="string">": "</span> &lt;&lt; elem.second &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-在set中使用："><a href="#2-在set中使用：" class="headerlink" title="2. 在set中使用："></a>2. 在<code>set</code>中使用：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::set&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">"One"</span>));</span><br><span class="line">    mySet.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">"Two"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) {</span><br><span class="line">        std::cout &lt;&lt; elem.first &lt;&lt; <span class="string">": "</span> &lt;&lt; elem.second &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>使用const auto&amp; 来列举时，每个元素是const pair&lt;&gt;类型。</p>
<h2 id="优先队列基础"><a href="#优先队列基础" class="headerlink" title="优先队列基础"></a>优先队列基础</h2><h3 id="priority-queue基础"><a href="#priority-queue基础" class="headerlink" title="priority_queue基础"></a>priority_queue基础</h3><p>CPP优先队列定义如下（需要<code>#include&lt;queue&gt;</code>)</p>
<p><code>priority_queue&lt;Type, Container, Functional&gt;</code></p>
<p>Container是存放元素的容器，默认用vector, Functional指出优先级的比较标准。</p>
<p>CPP的优先队列默认是大顶堆，Functional默认为less，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br></pre></td></tr></table></figure>

<p>如果想构造小顶堆，只需将Functional变为greater即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么默认为less就是大顶堆了呢？</p>
</blockquote>
<p>默认情况下，std::priority_queue使用std::less作为比较函数，这相当于比较运算符&lt;。这意味着，对于两个元素lhs和rhs (假设为bool operator()(const std::pair&lt;int, int&gt;&amp; lhs, const std::pair&lt;int, int&gt;&amp; rhs)：</p>
<p>​	•	如果lhs &lt; rhs返回true，则priority_queue认为rhs的优先级高于lhs。</p>
<p>也就是说，priority_queue默认认为返回true表示lhs应该在rhs之下，因此将较大的元素放在堆顶。</p>
<h3 id="自定义比较函数"><a href="#自定义比较函数" class="headerlink" title="自定义比较函数"></a>自定义比较函数</h3><p>这个Functional是可以自定义的，如果我们想把pair中second较小的放在堆顶，我们可以自定义比较函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>如此一来，当rhs.second小于lhs.second时，该函数返回true，rhs优先级比lhs高。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<ul>
<li>输入: nums = [1,1,1,2,2,3], k = 2</li>
<li>输出: [1,2]</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: nums = [1], k = 1</li>
<li>输出: [1]</li>
</ul>
<p>提示：</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度必须优于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.847ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4352.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1918.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3363.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3963.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
<h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>这题总的思想分为两部分： 统计频率，输出前k高元素。</p>
<h3 id="统计频率"><a href="#统计频率" class="headerlink" title="统计频率"></a>统计频率</h3><p>这题一开始我想的是空间换时间，即把nums数组中的元素看成下标，然后遍历数组，统计频率。这种方法只需要一个数组结构即可，但是由于我nums数组范围可以很大，导致可能会很浪费空间，于是改用map的方式统计频率。</p>
<p>map的方式也很简单明了。用哈希表的形式完成映射即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; um; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n:nums){</span><br><span class="line">    um[n] ++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="输出前k高元素"><a href="#输出前k高元素" class="headerlink" title="输出前k高元素"></a>输出前k高元素</h3><p>现在我们的任务是，如何选出map中前k高的值（只根据值不根据键来选），然后输出对应的键，我们希望这个过程的时间复杂度仅仅是n(这里的n代表map中的元素个数。</p>
<p>在这里我们抽象一下问题，不把它当作map来看，如果我们有一个int数组，我们想输出前k大的元素，如何在n的时间复杂度内完成这个任务呢？</p>
<p>如果用暴力算法，很显然需要kn的时间复杂度，从简单的情况出发，如果我们需要输出前2大的元素，我们只需要双指针即可，可双指针的方法也需要kn的时间复杂度。所以我们需要用空间换时间，考虑用一个数据结构来存储已经遍历过的有可能是最后解的结果，所以<code>堆</code>就成了这个数据结构的最佳选择。</p>
<p>我们构造一个大顶堆，将所有元素都插入到堆中，然后进行k次pop操作即可。但是除此之外，有一种更高效的方法，那就是构造一个k个元素的小顶堆，我们只需要将堆顶元素设置为第k大的元素即可，换句话说，<strong>只要将遍历到的比当前堆顶元素大的值插入到当前堆中，然后pop掉原来堆顶的值即可。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p: um){</span><br><span class="line">      <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &lt; k){  <span class="comment">// 先将minHeap的值填到k</span></span><br><span class="line">          minHeap.<span class="built_in">push</span>(p);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span>{</span><br><span class="line">          <span class="keyword">if</span> (minHeap.<span class="built_in">top</span>().second &lt; p.second){  <span class="comment">// 如果遍历元素比当前堆顶元素大，那么就置换它们</span></span><br><span class="line">              minHeap.<span class="built_in">pop</span>();</span><br><span class="line">              minHeap.<span class="built_in">push</span>(p);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()){  <span class="comment">// 最后输出minHeap中的first元素即可</span></span><br><span class="line">      ans.<span class="built_in">push_back</span>(minHeap.<span class="built_in">top</span>().first);</span><br><span class="line">      minHeap.<span class="built_in">pop</span>();</span><br><span class="line">  }</span><br></pre></td></tr></table></figure>



<p>这里minHeap的优先级不是pair的默认先比较键再比较值，而是基于值的最小堆，所以我们需要自定义函数来定义优先级。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myComparison</span>{</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p2)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>然后在主函数中如下声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, myComparison&gt; minHeap;</span><br></pre></td></tr></table></figure>

<p>本题思路不难，但是需要对CPP的STL容器进行融合使用，对练习STL容器来说是一道很好的习题。</p>
<h2 id="类似习题"><a href="#类似习题" class="headerlink" title="类似习题"></a>类似习题</h2><h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a><strong>合并K个排序链表</strong></h3><p>​	•	<strong>题目链接</strong>： <a href="https://leetcode.com/problems/merge-k-sorted-lists/">LeetCode 23. Merge k Sorted Lists</a></p>
<p>​	•	<strong>思路</strong>： 使用小顶堆将所有链表的头节点加入堆中，然后每次取出堆顶元素，将其后续节点再加入堆中，直到所有节点都被处理完。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">nodeComparison</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> ListNode* n1, <span class="type">const</span> ListNode* n2)</span></span>{</span><br><span class="line">            <span class="keyword">return</span> n1-&gt;val &gt; n2-&gt;val;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>{</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = ans;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, nodeComparison&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); i++){</span><br><span class="line">            <span class="keyword">if</span> (lists[i])</span><br><span class="line">                minHeap.<span class="built_in">push</span>(lists[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()){</span><br><span class="line">            <span class="keyword">if</span> (minHeap.<span class="built_in">top</span>()-&gt;next){</span><br><span class="line">                minHeap.<span class="built_in">push</span>(minHeap.<span class="built_in">top</span>()-&gt;next);</span><br><span class="line">            }</span><br><span class="line">            p-&gt;next = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><strong>合并区间</strong></p>
<p>​	•	<strong>题目链接</strong>： <a href="https://leetcode.com/problems/merge-intervals/">LeetCode 56. Merge Intervals</a></p>
<p>​	•	<strong>思路</strong>： 虽然这道题不直接使用优先队列，但它的思想和堆排序有相似之处。首先对区间进行排序，然后合并重叠的区间。</p>
<p>我的做法使用了优先队列，两个小顶堆的做法虽然改变了原来的区间对应关系，但是对结果没有影响。当然，想来最好的做法还是先排序再遍历去重。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) {</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq1;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i++){</span><br><span class="line">        pq1.<span class="built_in">push</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">        pq2.<span class="built_in">push</span>(intervals[i][<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!pq1.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="type">int</span> a = pq1.<span class="built_in">top</span>();</span><br><span class="line">        pq1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!pq1.<span class="built_in">empty</span>() &amp;&amp; pq1.<span class="built_in">top</span>() &lt;= pq2.<span class="built_in">top</span>()){</span><br><span class="line">            pq1.<span class="built_in">pop</span>();</span><br><span class="line">            pq2.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{a,pq2.<span class="built_in">top</span>()});</span><br><span class="line">        pq2.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>最佳做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) {</span><br><span class="line">      <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> interval : intervals) {</span><br><span class="line">          <span class="comment">// if the list of merged intervals is empty or if the current</span></span><br><span class="line">          <span class="comment">// interval does not overlap with the previous, simply append it.</span></span><br><span class="line">          <span class="keyword">if</span> (merged.<span class="built_in">empty</span>() || merged.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) {</span><br><span class="line">              merged.<span class="built_in">push_back</span>(interval);</span><br><span class="line">          }</span><br><span class="line">          <span class="comment">// otherwise, there is overlap, so we merge the current and previous</span></span><br><span class="line">          <span class="comment">// intervals.</span></span><br><span class="line">          <span class="keyword">else</span> {</span><br><span class="line">              merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> merged;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>微信读书导出pdf/epub/md/mobi</title>
    <url>/2024/07/15/2024-7-15-%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E5%AF%BC%E5%87%BApdfepubmdmobi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>书籍对我来说就像良药，总在我伤心难过的时候给我安慰，在我孤独寂寥的时候陪我左右，在我失去前行的动力的时候给我力量。其之于我就像一个家人，我对其敬佩有加，其对我关切备至。之前无意中在Greasyfork中搜索到一个脚本，可以将微信读书中的书籍内容导出成md或者html格式，当时我激动不已，觉得终于可以“书籍自由”了，我可以导出md然后在平板上写写画画，在电脑上记录读书的感想，不必局限于微信读书的条条框框（不过现在觉得其实微信读书社区非常强大，已经无法离开了hh）但是不知为何现在那个插件已经无法实现此功能了，我便怅然有种失落之感，觉得我与这位亲人顿时疏远了不少。为了重拾我的自由，我千方百计在网上寻找，终于找到了GitHub上大佬实现的代码，又经过一个下午的调试，终于成功实现书籍内容导出功能，其间看了许多中文英文的调试指南，又觉得与我今年所培养的debug专业能力非常贴合，于是记录文档如下。</p>
</blockquote>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Windows11 联想拯救者 2060Ti</li>
<li>Python 3.9.8</li>
<li>Chrome 126.0.6478.127</li>
<li>gtk3-runtime-3.24.29-2021-04-29</li>
</ul>
<h2 id="踩坑经验"><a href="#踩坑经验" class="headerlink" title="踩坑经验"></a>踩坑经验</h2><h3 id="1-安装wereader-exporter"><a href="#1-安装wereader-exporter" class="headerlink" title="1 安装wereader_exporter"></a>1 安装wereader_exporter</h3><p>按照 <a href="https://github.com/drunkdream/weread-exporter">https://github.com/drunkdream/weread-exporter</a> 链接中的教程，安装好所有的依赖库之后执行<code> python -m weread_exporter -b $book_id -o epub -o pdf</code>，结果报错：</p>
<p>Django：OSError: cannot load library ‘gobject-2.0-0’: error 0x7e.</p>
<h3 id="2-安装gtk3运行库"><a href="#2-安装gtk3运行库" class="headerlink" title="2 安装gtk3运行库"></a>2 安装gtk3运行库</h3><p>在网上找到了解答 <a href="https://www.cnblogs.com/melloliana/p/16098061.html">https://www.cnblogs.com/melloliana/p/16098061.html</a> ， 于是我按照教程安装了对应的运行时库，配置好环境变量（系统环境变量，位次设的比较高），并在wereader源代码的exporter.py文件下加上了<code>os.add_dll_directory(r"C:\Program Files\GTK3-Runtime Win64\bin")</code>。这下不报上面的gobject错了，程序也可以运行起来，但是运行的时候会显示<code>Fontconfig error: Cannot load default config file</code>错误，紧接着程序崩溃，只能关闭程序。</p>
<h3 id="3-官网安装weasyPrint"><a href="#3-官网安装weasyPrint" class="headerlink" title="3 官网安装weasyPrint"></a>3 官网安装weasyPrint</h3><p>我尝试了print调试法，锁定了出错的位置在import weasyPrint这句话上，那就是说这个第三方库还是有问题，那么问题在哪呢？我找到官网文档 <a href="https://doc.courtbouillon.org/weasyprint/latest/first_steps.html#missing-library">https://doc.courtbouillon.org/weasyprint/latest/first_steps.html#missing-library</a> ，遵照着教程，将weasyPrint重新安装了一遍，包括MSYS2， mingw-w64-x86_64-pango， 然后pip install，但是上面的问题仍然存在。</p>
<h3 id="4-卸载Graphviz，解决冲突"><a href="#4-卸载Graphviz，解决冲突" class="headerlink" title="4 卸载Graphviz，解决冲突"></a>4 卸载Graphviz，解决冲突</h3><p>然后我就在网上搜索这个font的问题，找到了最终的解决方案： <a href="https://github.com/Kozea/WeasyPrint/issues/1339">https://github.com/Kozea/WeasyPrint/issues/1339</a> 。问题在于，python的weasyPrint库依赖很多dll动态链接库，其中有一个链接库是fontconfig.dll，安装gtk的时候应该已经安装好了default config了，但是为什么在程序运行的时候还会出现这个问题呢？通过where指令可以返回类似<code>D:\Program Files\Graphviz\bin\fontconfig.dll</code>的结果，但是我们需要gtk的dll才行。所以我们卸载掉Graphviz之后再运行代码，这次就没有问题了。</p>
<h2 id="思考复盘"><a href="#思考复盘" class="headerlink" title="思考复盘"></a>思考复盘</h2><p>其实问题始终围绕着weasyPrint库展开，动态链接库的配置，python如何寻找到对应的dll，这些都是因为认知模糊才出现的问题。</p>
<p>在Windows系统中，使用<code>.dll</code>文件（动态链接库）可以通过几种不同的方式将它们集成到你的程序中。以下是一些常见的方法：</p>
<h4 id="1-动态加载-dll"><a href="#1-动态加载-dll" class="headerlink" title="1. 动态加载 .dll"></a>1. 动态加载 <code>.dll</code></h4><p>在运行时，程序可以使用Windows API函数（如<code>LoadLibrary</code>和<code>GetProcAddress</code>）动态加载和使用<code>.dll</code>文件中的函数。这种方法允许更大的灵活性，因为库可以在程序运行时被加载或卸载。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FunctionType)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 加载 DLL</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">"example.dll"</span>));</span><br><span class="line">    <span class="keyword">if</span> (hModule == <span class="literal">NULL</span>) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"加载DLL失败！"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数地址</span></span><br><span class="line">    FunctionType function = (FunctionType)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">"exampleFunction"</span>);</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="literal">NULL</span>) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"获取函数地址失败！"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">FreeLibrary</span>(hModule);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 DLL</span></span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hModule);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-静态链接-dll"><a href="#2-静态链接-dll" class="headerlink" title="2. 静态链接 .dll"></a>2. 静态链接 <code>.dll</code></h4><p>在编译时，程序可以静态链接到一个导入库（<code>.lib</code>文件），这个库提供了对<code>.dll</code>文件中导出的函数的引用。在链接时，链接器会使用导入库中的信息来解析对<code>.dll</code>文件中函数的调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"example.h"</span> <span class="comment">// DLL 导出的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">exampleFunction</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>在构建过程中，你需要将导入库（<code>example.lib</code>）链接到你的程序中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cl /EHsc example.cpp example.lib</span><br></pre></td></tr></table></figure>

<h4 id="3-配置运行时环境"><a href="#3-配置运行时环境" class="headerlink" title="3. 配置运行时环境"></a>3. 配置运行时环境</h4><p>无论是静态链接还是动态加载，你都需要确保<code>.dll</code>文件在程序运行时可以被找到。常见的方式包括：</p>
<ul>
<li>将<code>.dll</code>文件放在与可执行文件相同的目录中。</li>
<li>将<code>.dll</code>文件路径添加到系统的环境变量<code>PATH</code>中。</li>
<li>将<code>.dll</code>文件放在系统目录中（如<code>C:\Windows\System32</code>）。</li>
</ul>
<h4 id="Python-中使用-dll"><a href="#Python-中使用-dll" class="headerlink" title="Python 中使用 .dll"></a>Python 中使用 <code>.dll</code></h4><p>在Python中，许多第三方库（如WeasyPrint）使用<code>ctypes</code>或<code>cffi</code>库来加载和调用<code>.dll</code>文件中的函数。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 DLL</span></span><br><span class="line">example_dll = ctypes.CDLL(<span class="string">"example.dll"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">result = example_dll.exampleFunction()</span><br></pre></td></tr></table></figure>
<h2 id="发些牢骚"><a href="#发些牢骚" class="headerlink" title="发些牢骚"></a>发些牢骚</h2><p>出现上述问题的原因在于，当ctypes调用CDLL函数寻找对应的dll文件时，找到的是Graphviz错误版本的dll，由此才会导致程序崩溃，本质其实是和找CUDA_HOME一个道理，我们既配置了os.add_dll_directory，想让程序去对应的文件夹下寻找dll，但是环境变量已经配置了，而环境变量的优先级又高于library，所以才会报错，掌握了底层原理，排查起来就快了。</p>
<p>所谓“不患无位，患所以立”，不发愁没有职位，只发愁没有任职的本领，最近身边的人都在实习，越来越多的人都找到实习了，很多时候比较焦虑，觉得是不是自己的能力的问题，但其实我真正应该担心的是有没有和心中想要的职位匹配的本领，前段时间面试了一个AI Research Intern，但是我对大模型并不了解，所以没能得到这个职位，很多人找的实习只是为了让自己有钱拿，有实习经历可以写，但是所找的职位更多的还是拧螺丝的重复工作，或者并不是自己真正想去的公司。</p>
<p>我一直是个理想主义的“笨人“，我知道是应试教育之下的复习，但我还是力求能通读全书，建立系统性的思维再考试，而不是只针对考点；对于一些“没用”的科目比如美学培养，选修课等，我却觉得非常有趣，于是很认真的学；机器智能方向需要很多数学知识，我便买了Intro to Linear Algebra从头开始看书看视频学习，我其实怀抱的就是能全方面的了解某个领域，然后再加以应用的心，但我现在觉得这样的心态有些不务实，一方面是我在理科学习上天赋欠缺，没有深入的逻辑思维能力，另一方面我并没有掌握关联学习，反馈学习的刻意练习技巧，想一口吃成个胖子，期待着如果能这样的话势必会比别人更优秀，基础更牢，我觉得不然。</p>
<p>但是这样的学习方式是值得认可的，这样的想法在实用主义的时代必然是有价值的（人总要相信自己所走的路），我坚信世间的许多道理，他们的底层逻辑是互通的，是可以通过深入底层的关联学习触类旁通的，这也是我的初衷所在，我相信有一天当我度过了学习的平台期，量变转为质变之后，我就能更加心安理得地追寻那梦寐以求的自由了。</p>
]]></content>
      <categories>
        <category>踩坑经验</category>
      </categories>
      <tags>
        <tag>踩坑经验</tag>
      </tags>
  </entry>
  <entry>
    <title>人性的博弈</title>
    <url>/2024/07/18/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>假期赋闲在寝，每日在依照着虽不明确但有方向的学习计划推进之余，还留有许多空闲时间，看了一周的书，本想趁此空闲读读《苏东坡新传》，但是看了冰山一角后终于还是没有坚持下来，其中原因在于品读古文之艰难，成书虽为上世纪李冰先生所写，但其旁征博引，典故甚多，古今混杂，看的十分痛苦，可“读史以明智”，我不想这个计划死于襁褓，于是便问了GPT，其给我的建议是从史记、论语、孟子开始读，我便找到了《论语译注》开始通读，虽有不甚切合如今时代的言语，但亦有值得谨记的箴言，希望我能坚守本心，淡泊明志，宁静致远。兴许是文字摄入太多，昨日在吃外卖的时候想找点剧来看，跟进一下“多模态”的时代，于是便打开了在线影视网站，开始搜罗吸引我的剧集。老友记？短、幽默、下饭，但是我忘记上次看到哪了，懒得再次定位。冰冻星球，地球脉动？无聊不看。黑袍纠察队？天天刷短视频都在看，而且无脑，还不如我的外卖有营养。神探夏洛克？怕太烧脑了，把我用来刷算法题的脑细胞都用光了。鱿鱼游戏？只有九集还不错，之前听许多人讲过评价也可以，就它了！谁知道看了一集之后就上头了，熬到凌晨2点还在看，过瘾之外，感触良多。韩剧向来喜欢以最露骨地方式揭露人性，趁记忆还新鲜，记录如下。</p>
</blockquote>
<p>说来也巧，博弈论的英文是”Game Theory”，而《鱿鱼游戏》就是一场人性的游戏，所以标题取为“人性的博弈”个人觉得十分贴合主题。</p>
<p>这是一个偏远的小岛，聚集了456位濒临绝境的绿衣人，他们是游戏的参与者；还有圆形红衣人代表劳工，三角形红衣人代表枪手，方形红衣人代表管理者，还有一位黑衣负责人，以及戴着动物面具的贵宾们。这俨然就是一个资本主义社会的修罗场，管理者们冷血无情，机械地执行着上级的指令，参与者争斗不休，你死我活，为了承诺的“奖金”泯灭人性，扯下一切善良的遮羞布，像原始人一样，为了最基本的生存不顾一切。而贵宾们高高在上，为了寻找所谓的“乐趣”看着参与者厮杀，像赌马一样，为参与者的命运投注。参与者的生命，在这些人看来只是供他们取乐的消遣品。<br><img src="/img/squid1.png" alt="Pasted image 20240717202755"></p>
<p>男主角成奇勋一共玩了6场游戏，分别是123木头人，扣桠糖，拔河，弹弹珠，过桥以及最终的鱿鱼游戏，六轮游戏以及一些额外的剧情把最原始、最丑陋的人性展露无遗，在这种极致简单，极致残酷的规则下，生死存亡的博弈无时无刻不在上演。[1]<br><img src="/img/squid2.png" alt="Pasted image 20240718005035"><br>让我们用上帝视角看看，如果按照鱿鱼游戏的规则，带入自己是457号，那么要如何做才能所谓的“赢”呢？</p>
<p>首先要有一个<strong>处变不惊的心态</strong>，当我们知道被淘汰的结局是被枪射杀的时候要做到不慌不乱，不能因为蔓延的恐慌情绪乱了心智，要尽快平复心情，重新开始理智思考。</p>
<p>其次，<strong>不能只局限在每个人都知道的规则的范围内，要能多思考规则内外和边界上的可能性</strong>，比如说木头人跟在别人身后，扣桠糖用打火机或者用唾液融化，拔河向前走三步，骗阿里取得弹珠等。对规则清晰的认知，甚至能利用规则取胜，尚佑在游戏中就是这一类人，这也是他能活到最后一轮的重要原因。</p>
<p>再次，<strong>信息在博弈过程中非常重要</strong>，德秀正是因为掌握了信息才能在拔河中轻松取胜，姜晓以身犯险，获取到了重要的关卡信息，从而能够有准备地应对未知，这也为每一步的决策增添了底气。</p>
<p>然后，<strong>善于处理人际关系，尽量不要结怨结仇</strong>，在团队游戏里拥有良好的关系可以让自己有更多选择，也可以为自己带来更多信息，面临决策的时候可以更加游刃有余。</p>
<p>更进一步，<strong>有自己的独特价值，不随意展示自己的底牌</strong>，医生用自己的能力获取了关卡信息，加入了德秀的帮派，会看玻璃的人虽然还是被推下去了，但是如若没有被发现，肯定能够过得了关。如果有件关键的事情团队里只有一个人能做，那么可想而知此人的地位会有多高。</p>
<p>最后的最后，<strong>运气贯穿始终</strong>，如果被无针对性的有恶意的人陷害而被木头人检测到，被“我赢不了你也别赢”之类的人缠上，或者过桥关卡选了前面的号码，那么就算其他的能力再强也无济于事。</p>
<p><img src="/img/squid4.png" alt="Pasted image 20240717202755"></p>
<p>在这样一个残酷的生存游戏中，我实力与侥幸并存活到了最后，用信息差，欺诈，虚伪，背叛，同室操戈并手刃战友活到了最后，拿到了钱，成为了最后的赢家，那么我会快乐吗？我反复折磨自己，把自己“打造”成一个丧失人性的野兽，眼里只有输和赢，最后我“赢”了，但是我爱的人早已离我远去，身边也都是唯利是图的人，我赢得了游戏，却输了人生。</p>
<p>成奇勋在参与游戏之前是一个因为被迫下岗而一蹶不振，妻离子散，还得靠着年迈的老母亲养活的混混，不得不说第一集真的看的我气血上涌，差点喷饭，恨不得一拳打在这个人渣身上，虽说游戏过程中刻画了他的善良，但是我仍觉得不可原谅，同样参与游戏的许多人虽也生活难以为继，但参与游戏的原因是他们被外面的如地狱般的社会所坑害，不得已而来到游戏中，而就算在人吃人的游戏中，他们也将他们的善良一以贯之，带着他们的良知长眠地下。阿里，智英，姜晓皆是这样，这颇有一种 地狱充斥着善良的灵魂，而恶魔却在人间，死后升入天堂的信仰崩塌的感觉。</p>
<p><img src="/img/squid3.png" alt="Pasted image 20240718004812"></p>
<p>所以人生是一场鱿鱼游戏嘛？我认为既是也不是，一方面只要资源是有限的，而人的欲望是无限的，便会在竞争中争夺利益，若是零和博弈，便总会有输赢，若非零和博弈，相对之间亦会有高下之分，在当下加速内卷，学历贬值，中产阶级通道日益狭窄的时代下，鱿鱼游戏正在以成绩为好坏的标准中上演，正在千军万马过独木桥中上演，正在几百个人抢一个铁饭碗中上演，正在非生即走的晋升制度中上演。但关键的问题在于，我不如别人优秀，就等同于输了嘛？我不是走投无路之人，规则亦不是非生即死，博弈也非零和，正和的博弈比比皆是，在今天这个物质极度富裕的时代，就算“输”了也能活得很好，况且身边有那么多爱我的和我爱的人，所以我认为富人也好穷人也好，只要内心充盈，真切地感受到幸福快乐，在物欲横流和信仰崩塌的时代坚持耕耘自己的一亩三分地，“不患无位，患所以立”，不断成长和超越自己，便是赢。</p>
<p><img src="/img/squid5.png" alt="Pasted image 20240717202755"></p>
<p>最后以看到的很喜欢的一句话作结： “人生不是输赢游戏。人生这场游戏，到底怎样才算“赢”，应该由你自己来定义，而不是被别人定义。虽然如此，你可以玩“游戏”，也可以不玩“游戏”，但是千万别被“游戏”给玩了。”</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 游戏类型： <a href="https://www.huxiu.com/article/461999.html">https://www.huxiu.com/article/461999.html</a><br>[2] 影评： <a href="https://movie.douban.com/review/13879520/">https://movie.douban.com/review/13879520/</a></p>
]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>字节实习面经</title>
    <url>/2024/08/09/%E5%AD%97%E8%8A%82%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>最近在准备保研的机试和笔试题，《认知觉醒》中说，如果要深入地做好某件事，那么就应该：1.有明确的目标；2.极度专注；3.能获得有效的反馈；4.始终在拉伸区练习。笔试和机试范围就是408，机器学习，所以目标很明确，对于408来说就看考研书掌握概念，面试知道怎么答，笔试知道怎么写，机器学习就看课件和西瓜书即可。极度专注的话，我承认放假之后很多时候比较闲散，注意力不是很集中，但是这也可以通过规律去图书馆来改变。这些知识基本上都是之前所学过的，这次复习就相当于是修固一个系统的部件，所以大多数时候是处于拉伸区，学起来不会太痛苦，而且在一整个系统的体系下很方便关联学习，也能提高学习记忆的效率。所以我想要在有效反馈的地方下手，如何能获得有效反馈呢？我认为光靠我自己记忆，刷题是没有用的，可能刷题过了一周又忘了， 首先我需要获得一个持续进行下去的正向反馈，我认为对系统知识的复习和算法题AC就是正向反馈，因为我能实实在在地看到自己的成长，但是还需要一个能够检验我，约束我，鞭策我的负反馈，让我看到自己的差距以及努力的方向的反馈，于是我就想到了实习面试。参加实习面试，一方面可以让我熟悉面试场景和流程，不至于保研面试的时候生疏；另一方面也是检验我计算机基础知识，机器学习知识水平的场合，能够给予我有效的反馈，让我往我不熟悉的地方再努力。最后如果我能得到offer，那么还有💰拿，岂不乐哉？</p>
</blockquote>
<h2 id="面试经验"><a href="#面试经验" class="headerlink" title="面试经验"></a>面试经验</h2><p>昨天面试了字节的后端开发岗位，说起来这算是我的第一场技术面试，之前面试过SAP的AI相关岗位，但是在面试中只问了项目，其他的知识一概没问，所以我不把它看成是技术面试。对比起来，字节跳动的面试果然很硬核切，对于技术知识的拷问比较全面，下面总结我的面试过程和经验。</p>
<p>首先上来说要介绍自己，我没有提前准备自我介绍，于是说了一坨空话（什么终于可以把所学的知识学以致用了啥的）结果被提前打断，说：“好好好，反正你就是想找个实习嘛。”反正我其实也不是找实习嘛，所以倒也没在意他说啥，只想赶紧开始正题，体验一下字节的面试到底如何。</p>
<p>之后问我在学校里学了啥，我说学了计算机基础知识，数据结构，OS，计算机组成原理，计算机网络。然后问我除了这些，自己下来还学了啥，我就想到了MIT 的那个 Missing semester，说了Git, Linux，然后他就问我git的原理，当时就心想md真是给自己挖坑了，我支支吾吾没回答上来，然后就问Git怎么提交，这种问题我还是会的hh于是我就从Git init讲到Git push的全流程。</p>
<p>然后问我Linux 内核态和用户态的区别，我回答说内核态可以访问计算机比较底层的硬件，用户态不能，然后内核态的指令涉及很多临界资源，为了实现互斥访问，需要在内核态运行。虽然答的都有道理，但是答的很不全面， 最重要的安全性，稳定性没有明说，还可以答 简化系统设计，资源共享与隔离。然后问我虚拟内存的相关知识，这个我前一天才看，所以说的挺有道理，紧接着又问如果用户程序分配了大于系统内存的空间会怎么样，我说会直接报错或者交换内存（好像也没问题？）</p>
<p>然后问我熟悉哪种语言，我说C++，然后就问面向对象是什么，我就解释了封装、继承，我没说多态因为我忘了是啥了，然后问我懂不懂虚函数表，我说忘了，确实是不记得虚函数表是啥了，xs学C++的时候我还在学德语呢。然后问我C++的访问控制，Public, Private, Protected, 这个我还是会的。</p>
<p>之后就让我开始写算法题，第一道题是这个：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p><img src="/img/example.png" alt="image-20240809103623815"></p>
<p>好家伙，我一看就有点懵，之前没做过，有点小慌，之后想到可以用哈希表检验重复之后就好一些了，我总是避免去想那种暴力的算法，但是更好的想法我也没想出来，所以就消耗了很多时间，最后只想到并写下了哈希表的暴力算法，逐个遍历，但是其实可以记录重复的字符位置，遇到重复之后下一次直接从重复字符的下一位开始即可，这个我当时没想到，只能说面试环境确实不利于思考。下来我自己又做了一遍用哈希表的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s){</span><br><span class="line">            map[c] = <span class="number">-1</span>;  <span class="comment">// init, set to -1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>()){</span><br><span class="line">            <span class="keyword">if</span> (map[s[i]] == <span class="number">-1</span>){</span><br><span class="line">                map[s[i]] = i; <span class="comment">// 值取为下标</span></span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">// 遇到重复字符</span></span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, i - si);</span><br><span class="line">                si = map[s[i]] + <span class="number">1</span>; <span class="comment">// 重新设置开始下标</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = si;j &lt; s.<span class="built_in">length</span>() &amp;&amp; map[s[j]]!=<span class="number">-1</span>; j++)    map[s[j]] = <span class="number">-1</span>;  <span class="comment">// 如果重新更新之后已经是-1了，那么不需要继续进行了</span></span><br><span class="line">                i = si;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        maxLen = <span class="built_in">max</span>(maxLen, i - si);  <span class="comment">// 还要再求一次最大值</span></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>

<p>如果不加上对map重复初始化的限制条件<code>map[s[j]]!=-1</code>的话就会报超时的错。</p>
<p>做完这个题之后又开始问概念了，问我UDP和TCP的区别，真是经典老八股，我没有系统准备，只是凭借印象答了：可靠交付，流量控制与拥塞控制。倒也还行，扯了挺多，不过其实还有很多方面没答全，比如面向连接，使用场景，重传机制。</p>
<p>再之后就是我没复习到的HTTPS加密，这个我认栽，我忘记加密的内容了，也没复习，记不太清楚了。</p>
<p>然后问我数据库SQL的group by是什么意思,我不记得group by的具体应用场景，所以就根据这个 group by顾名思义，自创用法，把筛选的数据记录做分组，然后他也没继续问，估计是看出我数据库啥也不会hh</p>
<p>再之后又让我做题，这次是做用两个栈实现一个队列，这个我倒是熟，做了好多次了，很快就写出了代码，虽然有点小问题被他纠正了，但是也还好。我甚至觉得是他想快点挂掉我，不想让我浪费时间，所以来个简单的。不过我倒也看得开，啥题都可以做，不会就不会了hh只求个体验。</p>
<p>做完这个题也就快一个小时了，所以就问我有什么问题要问，我当时觉得反正肯定是挂，就不问了，于是就说没问题，就结束了。</p>
<p>上面就是整个面试过程，第一次技术面试，体验不能说好，因为很多问题都不会，但是确实体会到了大厂面试的感觉，也算是推开大门迈出第一步了。</p>
<p>人总要从自己和别人的失败里总结教训，下面我系统地梳理一下可以改进的点。</p>
<p>💡自我介绍提前准备，把自己的优势说清楚，然后引导面试官往自己熟悉的地方问，让面试官有一个“不选其他人而选我”的理由。Git，Vim，Linux都是我可以努力准备然后说出来的点。</p>
<p>💡对经典八股问题的掌握程度，对于Linux内核态，TCP/UDP，C++面向对象这种基础八股，要能够答得简洁而全面，不能磕磕巴巴，这个我觉得多准备多面试就行了，保研面试想必也会问，还得重点准备一下。</p>
<p>💡 算法题还是得多刷，其实第一题是哈希表，滑动窗口类型的，如果没有提前做过，现做的话还是挺难的，我觉得这次考我的两个算法题不算难题，只是我在面试环境下还是很难思考，不能很高效地说出想法罢了，保研虽然是机试，但其实也是一样的道理，只有多刷，明确地知道要往哪个方向下手，才能更快更稳地做完题目。</p>
<p>💡 对于自己不会的至少讲点套话，说自己疏漏了这方面知识的复习，掌握的不是很深入，下来会努力把这部分知识补全。人情世故也是我所欠缺的，不清楚也要说成我会变得清楚的，至少减分减的不要太多。</p>
<p>暂时就是这些感受，之后应该还会有面试，我认为这种负反馈有助于我精进，引用我母亲的话，“面试能力也是生存能力的重要体现”能够多练练这方面能力对我的未来也很重要。记录如上，路漫漫其修远兮，道阻且长， 继续加油吧！</p>
<h2 id="回答完整版"><a href="#回答完整版" class="headerlink" title="回答完整版"></a>回答完整版</h2><h3 id="Git的原理是什么？为什么能够做版本控制？"><a href="#Git的原理是什么？为什么能够做版本控制？" class="headerlink" title="Git的原理是什么？为什么能够做版本控制？"></a>Git的原理是什么？为什么能够做版本控制？</h3><p>Git 是一种分布式版本控制系统，用于管理代码和文件的变更历史。它的实现基于快照而不是增量。（<strong>快照</strong>（Snapshot）是指在特定时刻对项目所有文件和目录结构的一个完整记录。这与传统版本控制系统中的“增量”或“差异”记录方式不同。Git的快照机制是其高效管理代码和文件变更历史的核心概念之一。）</p>
<p>也就是说，每次提交（commit）时，<strong>Git会对当前项目的所有文件和目录结构做一个完整的记录，这个记录称为快照</strong>。但是并不是每次提交都把所有文件的内容完整地存储一遍，而是通过<strong>哈希指针</strong>来引用那些没有变化的文件。因此，只有变更的文件会被新存储，未变化的文件在提交时只会通过指针引用上一次提交的文件版本。这种快照机制给了Git一些很好的特性比如说高效的性能（不用计算增量），安全性和完整性（每个快照都是一个哈希值），易于回滚和恢复。</p>
<p><img src="/img/snapshot.png" alt="image-20240809111526340"></p>
<h3 id="Linux内核态和用户态的区别，为什么要设立这两个态呢？"><a href="#Linux内核态和用户态的区别，为什么要设立这两个态呢？" class="headerlink" title="Linux内核态和用户态的区别，为什么要设立这两个态呢？"></a>Linux内核态和用户态的区别，为什么要设立这两个态呢？</h3><p>当执行系统调用，中断程序或者程序处理异常时，操作系统会转换为内核态，内核态能够执行特权指令，操作操作系统内核的代码，包括设备驱动程序、进程调度、内存管理、文件系统等核心组件，另外可以访问内存地址，直接操作硬件资源。（执行特权操作，访问硬件资源）用户态主要运行用户程序代码，具有较低的权限，只能访问有限的内存空间。</p>
<p>划分这两种运行模式的原因在于：</p>
<p><strong>可以提高操作系统的安全性</strong>， 不让用户程序随意滥用系统资源，防止恶意代码对系统造成破坏。</p>
<p><strong>可以提升系统的稳定性</strong>。用户态与内核态的分离确保了用户程序的错误不会直接影响操作系统的核心功能。如果用户程序出现错误，那么将会由内核态进行异常处理，不会影响到其他应用程序的正常执行，保证了系统的稳定性。</p>
<p><strong>可以简化系统设计</strong>，通过这种分离，内核态的代码可以专注于处理低级别的系统操作，而用户态则专注于处理应用程序逻辑。开发者可以无需关心复杂的硬件问题，而直接通过调用API来实现各种功能。</p>
<p><strong>可以更好实现资源共享和隔离</strong>，通过用户态和内核态的分离，操作系统可以实现进程之间的隔离，每个进程只访问自己的资源，无法干涉其他进程。对于需要共享资源的进程，统一由内核态管理，确保资源的同步和一致性。</p>
<h3 id="虚拟内存是什么？"><a href="#虚拟内存是什么？" class="headerlink" title="虚拟内存是什么？"></a>虚拟内存是什么？</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。为了更好的管理内存，操作系统将内存抽象成地址空间，每个程序有自己的地址空间，这个地址空间又被分成很多个页面，页面被映射到物理内存中，页面映射不需要映射到连续的地址空间，也不需要每一页都有对应的物理地址。当程序引用到不在物理内存中的页时，硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。这使得有限的内存运行大程序成为可能。</p>
<p>物理内存就像缓存，当程序引用了不在物理内存中的页时，物理内存“不命中”，于是缺页中断，请求调页，从磁盘里把对应的页掉进物理内存里，但是如果此时物理内存如果已经满了的话就要页面置换了。</p>
<h3 id="malloc超过物理内存的空间"><a href="#malloc超过物理内存的空间" class="headerlink" title="malloc超过物理内存的空间"></a>malloc超过物理内存的空间</h3><p>当你使用 <code>malloc</code> 在 C 或 C++ 中请求分配大于系统实际可用内存的空间时，会出现以下几种情况，具体结果取决于操作系统和内存管理机制：</p>
<h4 id="1-内存分配失败（返回-NULL）"><a href="#1-内存分配失败（返回-NULL）" class="headerlink" title="1. 内存分配失败（返回 NULL）"></a>1. <strong>内存分配失败（返回 <code>NULL</code>）</strong></h4><ul>
<li><strong>行为</strong>：在大多数情况下，如果 <code>malloc</code> 请求的内存超过了系统实际可用的内存（包括物理内存和交换空间），<code>malloc</code> 会失败，并返回 <code>NULL</code> 指针。</li>
<li><strong>后果</strong>：程序应检查 <code>malloc</code> 的返回值。如果返回 <code>NULL</code>，表示内存分配失败，程序可以选择处理这种情况，例如释放其他资源、报告错误或退出程序。</li>
</ul>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(very_large_size);</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Memory allocation failed!\n"</span>);</span><br><span class="line">    <span class="comment">// Handle the error, possibly exit the program</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-操作系统的过度分配（Overcommit）"><a href="#2-操作系统的过度分配（Overcommit）" class="headerlink" title="2. 操作系统的过度分配（Overcommit）"></a>2. <strong>操作系统的过度分配（Overcommit）</strong></h4><ul>
<li><p><strong>行为</strong>：在某些操作系统（如Linux）中，内存分配可能会“成功”，即 <code>malloc</code> 返回了一个非 <code>NULL</code> 的指针，尽管请求的内存实际上超出了系统的可用内存。这是因为操作系统使用了一种称为“过度分配”（overcommit）的策略，在实际使用（如访问）这块内存之前不会真正分配物理内存。</p>
</li>
<li><p><strong>后果</strong>：当你实际尝试使用这块超出系统内存的区域时（即访问这个内存区域），系统可能会遇到内存不足的情况。这时操作系统可能会触发<code>OOM Killer</code>（Out-Of-Memory Killer）来终止某些进程，通常会选择终止当前请求大内存的进程，以释放内存空间。</p>
</li>
<li><p><strong>风险</strong>：虽然 <code>malloc</code> 似乎成功了，但实际使用这些内存时程序可能会崩溃或被操作系统强制终止。因此，即使 <code>malloc</code> 成功，分配非常大的内存时，仍应谨慎处理并监控内存使用。</p>
</li>
</ul>
<h4 id="3-虚拟内存的使用"><a href="#3-虚拟内存的使用" class="headerlink" title="3. 虚拟内存的使用"></a>3. <strong>虚拟内存的使用</strong></h4><ul>
<li><strong>行为</strong>：在现代操作系统中，虚拟内存管理允许程序请求的内存比物理内存大得多。虚拟内存由物理内存和交换空间（swap）组成。当请求的内存超过物理内存时，操作系统会尝试将一些内存页调入交换空间，尽量满足分配请求。</li>
<li><strong>后果</strong>：即使 <code>malloc</code> 成功，使用大量虚拟内存会导致系统性能严重下降（即“抖动”现象），因为频繁的页面调度（page swapping）会显著增加磁盘I/O，减慢整个系统的响应速度。</li>
</ul>
<h4 id="4-内存不足导致的异常终止"><a href="#4-内存不足导致的异常终止" class="headerlink" title="4. 内存不足导致的异常终止"></a>4. <strong>内存不足导致的异常终止</strong></h4><ul>
<li><strong>行为</strong>：在某些情况下，如果程序继续访问过多的内存，系统可能会无法分配足够的物理内存或交换空间。操作系统可能无法继续为该进程分配更多内存，最终导致程序异常终止。</li>
<li><strong>后果</strong>：这种情况通常伴随着系统日志中的<code>OOM</code>信息，程序会收到<code>SIGKILL</code>或<code>SIGSEGV</code>信号而终止。</li>
</ul>
<h3 id="C-问题"><a href="#C-问题" class="headerlink" title="C++ 问题"></a>C++ 问题</h3><p>C++面向对象特性： <a href="https://blog.csdn.net/cui_yonghua/article/details/131376206">https://blog.csdn.net/cui_yonghua/article/details/131376206</a></p>
<p>C++虚函数表： <a href="https://blog.csdn.net/Primeprime/article/details/80776625">https://blog.csdn.net/Primeprime/article/details/80776625</a></p>
<p>（GPT）C++中的多态是面向对象编程（OOP）的一个重要特性，它允许相同的接口以不同的方式执行，具体表现为“<strong>一个接口，多种实现</strong>”。多态主要通过<strong>函数重载</strong>、<strong>运算符重载</strong>和<strong>虚函数</strong>实现。以下是C++多态的简要介绍：</p>
<h4 id="1-静态多态（编译时多态）"><a href="#1-静态多态（编译时多态）" class="headerlink" title="1. 静态多态（编译时多态）"></a>1. <strong>静态多态（编译时多态）</strong></h4><p>静态多态是在编译时决定的，它包括<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<ul>
<li><p><strong>函数重载</strong>：</p>
<ul>
<li>同一作用域中可以有多个同名函数，但这些函数的参数列表（参数个数或类型）必须不同。编译器在编译时根据函数调用的参数类型和数量来确定调用哪个函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Integer: "</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Double: "</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string s)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"String: "</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运算符重载</strong>：</p>
<ul>
<li>C++允许开发者为自定义类型重载运算符，使得这些类型的实例可以使用类似于内置类型的运算符（如<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>）来操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) {}</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="type">const</span> Complex &amp;c) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + c.real, imag + c.imag);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-动态多态（运行时多态）"><a href="#2-动态多态（运行时多态）" class="headerlink" title="2. 动态多态（运行时多态）"></a>2. <strong>动态多态（运行时多态）</strong></h4><p>动态多态是在运行时通过<strong>虚函数</strong>和<strong>继承</strong>实现的，它是C++多态的核心，也是OOP的一个关键特性。</p>
<ul>
<li><p><strong>虚函数</strong>：</p>
<ul>
<li>当基类中的函数被声明为<code>virtual</code>时，该函数可以在派生类中被重写。当基类的指针或引用指向派生类对象时，通过该指针或引用调用虚函数时，会根据实际对象的类型调用派生类的版本，而不是基类的版本。这种机制称为“动态绑定”或“后期绑定”。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base class show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived class show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    b-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出: Derived class show function</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>纯虚函数和抽象类</strong>：</p>
<ul>
<li>如果一个类中包含至少一个纯虚函数（即<code>virtual void func() = 0;</code>），那么这个类就是抽象类，不能直接实例化。派生类必须实现所有的纯虚函数，才能实例化。抽象类通常用于定义接口，派生类用于实现这些接口。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Drawing Circle"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-多态的应用"><a href="#3-多态的应用" class="headerlink" title="3. 多态的应用"></a>3. <strong>多态的应用</strong></h4><p>多态性使得代码具有更好的扩展性和灵活性。通过多态，程序可以处理不同类型的对象，而无需知道这些对象的具体类型。例如，可以通过一个基类指针数组存储不同类型的派生类对象，并通过遍历数组调用它们的虚函数。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>静态多态</strong>：在编译时确定，通过函数重载和运算符重载实现。</li>
<li><strong>动态多态</strong>：在运行时确定，通过虚函数和继承实现，是C++多态的核心。</li>
</ul>
<p>多态是C++中实现代码复用和灵活设计的强大工具，特别是在使用继承和面向对象编程时，动态多态使得代码能够在运行时根据实际对象的类型表现出不同的行为。</p>
<h3 id="TCP-x2F-UDP"><a href="#TCP-x2F-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>UDP（User Datagram Protocol）和TCP（Transmission Control Protocol）是互联网协议栈中两种最常用的传输层协议。它们在数据传输方式、可靠性、连接性、以及使用场景等方面有显著的区别。以下是UDP和TCP的主要区别：</p>
<h4 id="1-连接性"><a href="#1-连接性" class="headerlink" title="1. 连接性"></a>1. <strong>连接性</strong></h4><ul>
<li><strong>TCP</strong>：面向连接的协议。在传输数据之前，TCP需要建立一个连接，这个过程称为“三次握手”（Three-way Handshake）。三次握手确保双方都准备好进行通信，并且可以通过确认号和序列号来管理数据传输的顺序和完整性。</li>
<li><strong>UDP</strong>：无连接的协议。UDP在传输数据之前不需要建立连接，数据直接通过数据报（datagram）的形式发送。这意味着发送方不会等待接收方的确认，也没有会话管理的概念。</li>
</ul>
<h4 id="2-可靠性"><a href="#2-可靠性" class="headerlink" title="2. 可靠性"></a>2. <strong>可靠性</strong></h4><ul>
<li><strong>TCP</strong>：提供可靠的数据传输。TCP通过确认（ACK）、序列号、重传机制和流量控制等手段，确保数据按顺序、完整地到达接收方。如果数据丢失或出现错误，TCP会自动进行重传。</li>
<li><strong>UDP</strong>：不保证数据的可靠性。UDP不提供数据重传、确认、或排序功能，数据包可能会丢失、重复或乱序到达。UDP的简单性使其效率更高，但可靠性较低。</li>
</ul>
<h4 id="3-流量控制与拥塞控制"><a href="#3-流量控制与拥塞控制" class="headerlink" title="3. 流量控制与拥塞控制"></a>3. <strong>流量控制与拥塞控制</strong></h4><ul>
<li><strong>TCP</strong>：支持流量控制和拥塞控制。TCP使用滑动窗口机制来控制数据流的传输速度，防止网络拥塞，并确保接收方不会被数据流淹没。TCP会动态调整传输速率以适应网络状况。</li>
<li><strong>UDP</strong>：不提供流量控制和拥塞控制。UDP的数据传输速率完全取决于发送方，网络拥塞或接收方的处理能力不足可能会导致数据丢失。</li>
</ul>
<h4 id="4-数据传输方式"><a href="#4-数据传输方式" class="headerlink" title="4. 数据传输方式"></a>4. <strong>数据传输方式</strong></h4><ul>
<li><strong>TCP</strong>：面向字节流的协议。数据被分成一个个字节流，这些字节流通过TCP连接可靠传输，接收方会按顺序接收并重组这些字节流。</li>
<li><strong>UDP</strong>：面向报文的协议。数据以独立的报文段（datagram）形式发送，每个报文段是一个独立的包，接收方以报文段的形式接收数据，报文段之间没有顺序关系。</li>
</ul>
<h4 id="5-开销与性能"><a href="#5-开销与性能" class="headerlink" title="5. 开销与性能"></a>5. <strong>开销与性能</strong></h4><ul>
<li><strong>TCP</strong>：由于TCP需要建立连接、管理会话、重传丢失数据以及执行流量控制等，因此TCP的头部信息较大，且会有更多的处理开销。这些特性使得TCP更加可靠，但在某些场景下，可能会带来较大的延迟和带宽消耗。</li>
<li><strong>UDP</strong>：UDP头部信息小，处理开销低，因为它不提供连接建立、会话管理、数据重传等功能。因此，UDP适合需要快速传输、低延迟的数据传输场景。</li>
</ul>
<h4 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. <strong>使用场景</strong></h4><ul>
<li><strong>TCP</strong>：适用于需要高可靠性的数据传输场景，如网页浏览（HTTP/HTTPS）、文件传输（FTP）、电子邮件（SMTP）、远程登录（SSH）等。TCP的可靠性和顺序性确保了数据在传输过程中不会出现错误。</li>
<li><strong>UDP</strong>：适用于对传输速度和实时性要求较高，但对可靠性要求较低的场景，如视频流媒体传输（如YouTube、Netflix）、在线游戏、实时语音或视频通信（如VoIP、Zoom）、DNS查询等。UDP的低延迟特性使其非常适合这些实时应用。</li>
</ul>
<h4 id="7-头部结构"><a href="#7-头部结构" class="headerlink" title="7. 头部结构"></a>7. <strong>头部结构</strong></h4><ul>
<li><strong>TCP头部</strong>：<ul>
<li>TCP头部较为复杂，至少包含20字节的固定部分，包括源端口、目标端口、序列号、确认号、标志位（如SYN、ACK、FIN等）、窗口大小、校验和等。额外的选项部分可以进一步增加头部的长度。</li>
</ul>
</li>
<li><strong>UDP头部</strong>：<ul>
<li>UDP头部简单，只有8字节，包括源端口、目标端口、长度和校验和字段。由于头部信息较少，UDP的传输效率较高。</li>
</ul>
</li>
</ul>
<h4 id="8-重传机制"><a href="#8-重传机制" class="headerlink" title="8. 重传机制"></a>8. <strong>重传机制</strong></h4><ul>
<li><strong>TCP</strong>：如果接收方未在特定时间内收到数据或ACK确认，则发送方会自动重传丢失的数据段。这种机制确保了数据传输的完整性和正确性。</li>
<li><strong>UDP</strong>：不提供自动重传机制。如果数据包丢失，发送方不会重传，这意味着应用程序需要自行处理丢失的数据包。</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>TCP</strong>：面向连接的、可靠的、按序传输的协议，适用于需要高可靠性和数据完整性的场景，但开销较大，传输速度相对较慢。</li>
<li><strong>UDP</strong>：无连接的、不可靠的、无需按序的协议，适用于对实时性要求高、容忍一定数据丢失的场景，具有较低的开销和更高的传输速度。</li>
</ul>
<h3 id="HTTP-x2F-HTTPS问题："><a href="#HTTP-x2F-HTTPS问题：" class="headerlink" title="HTTP/HTTPS问题："></a>HTTP/HTTPS问题：</h3><p><a href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E4%B8%80-%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E4%B8%80-%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5</a></p>
<h3 id="数据库Group-By"><a href="#数据库Group-By" class="headerlink" title="数据库Group By"></a>数据库Group By</h3><p><a href="https://blog.csdn.net/weixin_45188218/article/details/137637633">https://blog.csdn.net/weixin_45188218/article/details/137637633</a></p>
<p>保研真的会问HTTPS和数据库问题嘛？存疑，我现在暂时没有详细对这方面复习，如果需要的话再看。。</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
